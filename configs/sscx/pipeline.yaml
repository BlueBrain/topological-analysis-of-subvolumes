

# #+RESULTS:
# : Welcome to EMACS Jupyter
# #+title: Connsense Topology Pipeline for SSCx

# We an provide a litte header for the pipeline
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::+begin_src yaml][No heading:2]]
description: >-
  Configure a connsense subTarget Analysis Pipeline to analyze your circuit.
version: 0.1.0
date: <2023-02-13 Mon>
# No heading:2 ends here

# We need to set paths to the artefacts that the pipeline will use. We set paths for the circuit to analyze, and the root space for the pipeline's HDF5 stores, and the HDF5 group for each of the pipeline steps.
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*paths][paths:1]]
paths:
  description: >-
    The ~connsense~ pipeline needs paths to the input data to load from, and output paths to store data.
    Paths to the circuit must be provided along with paths to the HDF5 archive that will store the pipeline's
    results.
  format: relative
  circuit:
    root: "/gpfs/bbp.cscs.ch/project/proj83/circuits"
    files:
      Bio_M: "Bio_M/20200805/CircuitConfig_TC_WM"
  pipeline:
    root: "/gpfs/bbp.cscs.ch/project/proj83/home/sood/topological-analysis-subvolumes/test/v2"
    input:
      store: "connsense.h5"
    output:
      store: "connsense.h5"
    steps:
      define-subtargets: "subtargets"
      extract-node-populations: "nodes/populations"
      extract-edge-populations: "edges/populations"
      analyze-connectivity: "analyses/connectivity"
# paths:1 ends here

# We provide the parameters for each step.
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*parameters][parameters:1]]
parameters:
  description: >-
    Provide parameters that apply to each step.
# parameters:1 ends here

# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*define-subtargets][define-subtargets:1]]
  define-subtargets:
    description: >-
      Configure the subtargets to analyze, entrying each definition as a key, value.
    definitions:
# define-subtargets:1 ends here

# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*flatmap-columns][flatmap-columns:1]]
      flatmap-columns:
        description: >-
          Hexaongal prism like columns oriented along cortical layers,
          from white-matter to pia.  The data is loaded from an NRRD file that maps each
          circuit voxel to a subtarget ids corresponding to a flatmap column.The subtarget
          ids should be mapped to the subtargets they refer to in a dataframe provided as
          the input `info`.
        input:
          circuit:
          - "Bio_M"
        kwargs:
          path: "/gpfs/bbp.cscs.ch/project/proj83/home/reimann/subvolumes/column_identities.nrrd"
          info: "/gpfs/bbp.cscs.ch/project/proj83/home/reimann/subvolumes/voxel-based-hex-grid-info-with-conicality.h5"
        loader:
          source: connsense.define_subtargets.flatmap
          method: load_nrrd
# flatmap-columns:1 ends here

# Within ~connsense~ we use an ~internal~ index for ~subtarget, circuit, connectome~. While we can infer this information from [[paths]] and [[define-subtargets]], we have not yet (<2023-02-13 Mon>) implemented this feature.
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*create-index][create-index:1]]
  create-index:
    description:
      Create tap-store indices by listing datasets for each index variable.
    variables:
      circuit:
        - "Bio_M"
      connectome:
        - "local"
        - "intra_SSCX_midrange_wm"
        - "Thalamocortical_input_VPM"
        - "Thalamocortical_input_POM"
      subtarget:
        dataset: ["define-subtargets", "flatmap-columns/name"]
# create-index:1 ends here

# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*extract-node-populations][extract-node-populations:1]]
  extract-node-populations:
    description: >-
      Specify the populations to extract from a circuit.
    populations:
# extract-node-populations:1 ends here

# The population of /non-barrel/ SSCx biophysical nodes will be the node-population that we analyze,
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*default][default:1]]
      default:
        description: >-
          The default population will be that of neurons in the SSCx.
          To extract the neurons we will use a `connsense` method that uses ~bluepy~.
        input:
          subtarget:
            dataset:  ["define-subtargets", "flatmap-columns"]
          circuit:
            - "Bio_M"
        kwargs:
          properties:
            - region
            - layer
            - x
            - y
            - z
            - depth
            - synapse_class
            - mtype
            - etype
            - morphology
        extractor:
          source: connsense.extract_nodes.bluepy
          method: extract_node_properties
        output: "pandas.DataFrame"
# default:1 ends here

# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*extract-edge-populations][extract-edge-populations:1]]
  extract-edge-populations:
    description: >-
      Specify the edge populations to extract from a circuit.
    populations:
# extract-edge-populations:1 ends here

# We will analyze topology of the ~local~ connectome that consists of the connections among cells based on their axo-dendritic appositions. To study the local connectivity of a ~subtarget~, we will need it's adjacency matrix that we can extract to the ~TAPStore~.

# *** local
# The population of local connections resulting from axo-dendritic appositions,
# #+name: local-edges
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::local-edges][local-edges]]
      local:
        input:
          subtarget:
            dataset:  ["define-subtargets", "flatmap-columns"]
          circuit:
            - "Bio_M"
          connectome:
            - "local"
        extractor:
          source: micasa.connsense.develop.extract.edge_populations.extract_connectivity
          method: extract_adj
        output: "sparse.spmatrix"
# local-edges ends here


# experiment with,
# #+name: long-range-sources
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::long-range-sources][long-range-sources]]
      long-range-cross:
        input:
          pre:
            dataset: ["define-subtargets", "flatmap-columns"]
          circuit:
            - "Bio_M"
          connectome:
            - "intra_SSCX_midrange_wm"
          post:
            dataset: ["define-subtargets", "flatmap-columns"]
          join: CROSS
        extractor:
          source: micasa.connsense.develop.extract.edge_populations.extract_connectivity
          method: extract_cross_adj
        output: "sparse.spmatrix"
# long-range-sources ends here


# We can also have local cross adj,
# #+name: local-cross
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::local-cross][local-cross]]
      local-cross:
        input:
          pre:
            dataset: ["define-subtargets", "flatmap-columns"]
            subset: [[100, 0], [9, 0]]
          circuit:
            - "Bio_M"
          connectome:
            - "local"
          post:
            dataset: ["define-subtargets", "flatmap-columns"]
          join: CROSS
        extractor:
          source: micasa.connsense.develop.extract.edge_populations.extract_connectivity
          method: extract_cross_adj
        output: "sparse.spmatrix"
# local-cross ends here

# We will analyze several phenomena related to network topology, each entered in ~analyses~,
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*analyze-connectivity][analyze-connectivity:1]]
  analyze-connectivity:
    description: >-
      Configure each analyses' parameters, as a mapping under section `analyses`.
    analyses:
# analyze-connectivity:1 ends here

# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*description][description:1]]
      simplex-counts:
        description: >-
          Number of simplices by dimension.
# description:1 ends here

# We will compute ~simplex-counts~ for each of the ~flatmap-columns~, using ~adjacency~ matrices that we extract as dataset ~("extract-edge-populations", "local")~. We will also use ~node_properties~ that we extract as ~node-population~ ~default~.
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*input][input:1]]
        input:
          node_properties:
            dataset: ["extract-node-populations", "default"]
          adjacency:
            dataset: ["extract-edge-populations", "local"]
# input:1 ends here

# We will use random controls for each ~subtarget~, entering them by name and value. We start with Erdos-Renyi controls, 5 of them specified by seed.
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*controls][controls:1]]
        controls:
          erdos-renyi:
            description: >-
              Erdos-Renyi shuffle of edges.
            seeds: [0, 1, 2, 3, 4]
            algorithm:
              source: "/gpfs/bbp.cscs.ch/project/proj83/analyses/topological-analysis-subvolumes/proj83/connectome_analysis/library/randomization.py"
              method: "ER_shuffle"
          dd2:
            description: >-
              Apply DD2, a second order distance dependent model, to rewire the circuit.
            seeds: [0, 1, 2, 3, 4]
            algorithm:
              source: "/gpfs/bbp.cscs.ch/project/proj83/analyses/topological-analysis-subvolumes/proj83/connectome_analysis/library/randomization.py"
              method: "run_DD2_model"
            tap_datasets:
              model_params_dd2: ["analyze-connectivity", "model-params-dd2"]
# controls:1 ends here

# We will slice each ~subtarget~ into ~subtgraphs~ consisting of each of the cortical layers. Thus a single ~subtarget~ should give us 6 of these ~slicings~. To compute analysis on a ~slicing~ we will have to enter it inside the ~analysis~ config.

# We may store computation of each slice of a single subtarget as a ~datacall~. This will result in each slice of each subtarget to be sequenced as a ~unit-computation~. In ~connsense-parallelization~, we then parallelize based on the sizes of all the slices. The computation is seprated from that of ~full-subtargets~. This does not work well with ~simplex-counts~ as ~datacall~ of a single ~slice~ requires us to first load the adjacency matrices, then control them. With large adjacency matrices the computation of a unit ~slice-subtarget~ will require the same resources as loading the original full and randomizing it. Instead we will have to serially compute the slices' simplex-counts for each subtarget.

# We can specify this in the config as ~compute_mode: EXECUTE~, instead of ~DATACALL~ which will create individual ~datacalls~, or ~DATASET~ that should save each ~slice-subtarget~ to a ~TapDataset~.
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*slicing][slicing:1]]
        slicing:
          description: >-
            Slice analysis input according to some rules.
          do-full: true #to run the original full matrices as well...
          layer:
            description: >-
              Intralayer subgraphs.
            compute_mode: EXECUTE
            slices:
              layer: [1, 2, 3, 4, 5, 6]
            algorithm:
              source: "/gpfs/bbp.cscs.ch/project/proj83/analyses/topological-analysis-subvolumes/proj83/connectome_analysis/library/topology.py"
              method: "subgraph_intralayer"
# slicing:1 ends here

# Finally, we need to specify the method to use to compute ~simplex-counts~ for each ~subtarget~, and the data-type of it's output.
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*computation][computation:1]]
        computation:
          source: "/gpfs/bbp.cscs.ch/project/proj83/analyses/topological-analysis-subvolumes/proj83/connectome_analysis/library/topology.py"
          method: "simplex_counts"
        output: "pandas.Series"
# computation:1 ends here

# This analysis is used to create parameters for the distance dependent connection-probablity order 2 control model.
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*model-params-dd2][model-params-dd2:1]]
      model-params-dd2:
        description: >-
          Parameters for distance dependent connectivity model of order 2.
          Note that the `coord_names` in key `kwargs:` must agree with the configuration
          of the control model that will use the results of this analysis.
# model-params-dd2:1 ends here

# We will compute ~simplex-counts~ for each of the ~flatmap-columns~, using ~adjacency~ matrices that we extract as dataset ~("extract-edge-populations", "local")~. We will also use ~node_properties~ that we extract as ~node-population~ ~default~.
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*input][input:1]]
        input:
          node_properties:
            dataset: ["extract-node-populations", "default"]
          adjacency:
            dataset: ["extract-edge-populations", "local"]
# input:1 ends here

# Finally, we need to specify the method to use to compute ~simplex-counts~ for each ~subtarget~, and the data-type of it's output.
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*computation][computation:1]]
        computation:
          source: "/gpfs/bbp.cscs.ch/project/proj83/analyses/topological-analysis-subvolumes/proj83/connectome_analysis/library/modelling.py"
          method: "conn_prob_2nd_order_model"
        output: "pandas.DataFrame"
# computation:1 ends here

# The method that we will use to compute model parameters needs these parameters,
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*kwargs][kwargs:1]]
        kwargs:
          bin_size_um: 50
          max_range_um: 1000
          sample_size: null
          coord_names: ["x", "y", "z"]
# kwargs:1 ends here

# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*description][description:1]]
      thalamic-innervation:
        description: >-
          Number of thalamo-cortical synapses at each cell in a subtarget.
# description:1 ends here

# We will compute ~simplex-counts~ for each of the ~flatmap-columns~, using ~adjacency~ matrices that we extract as dataset ~("extract-edge-populations", "local")~. We will also use ~node_properties~ that we extract as ~node-population~ ~default~.
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*input][input:1]]
        vpm:
          description: >-
            Thalamic innervation of a subtarget, that originates in the VPM.
          input:
            subtarget:
              dataset: ["define-subtargets", "flatmap-columns"]
            circuit:
              - "Bio_M"
            connectome:
              - "Thalamocortical_input_VPM"
# input:1 ends here

# Finally, we need to specify the method to use to compute ~simplex-counts~ for each ~subtarget~, and the data-type of it's output.
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*computation][computation:1]]
          computation:
            source: micasa.connsense.develop.analyze.composition.projections.projections
            method: "innervate_cells"
          output: "pandas.Series"
# computation:1 ends here

# We will compute ~simplex-counts~ for each of the ~flatmap-columns~, using ~adjacency~ matrices that we extract as dataset ~("extract-edge-populations", "local")~. We will also use ~node_properties~ that we extract as ~node-population~ ~default~.
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*input][input:1]]
        pom:
          description: >-
            Thalamic innervation of a subtarget, that originates in the VPM.
          input:
            subtarget:
              dataset: ["define-subtargets", "flatmap-columns"]
            circuit:
              - "Bio_M"
            connectome:
              - "Thalamocortical_input_POM"
# input:1 ends here

# Finally, we need to specify the method to use to compute ~simplex-counts~ for each ~subtarget~, and the data-type of it's output.
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*computation][computation:1]]
          computation:
            source: micasa.connsense.develop.analyze.composition.projections.projections
            method: "innervate_cells"
          output: "pandas.Series"
# computation:1 ends here

# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*description][description:1]]
      wm-innervation:
        description: >-
          Number of thalamo-cortical synapses at each cell in a subtarget.
# description:1 ends here

# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*input][input:1]]
        input:
          subtarget:
            dataset: ["define-subtargets", "flatmap-columns"]
          source_nodes:
            dataset: ["circuit-node-populations", "default"]
          circuit:
            - "Bio_M"
          connectome:
            - "intra_SSCX_midrange_wm"
        kwargs:
          summarize_source: ["subtarget"]
# input:1 ends here

# Finally, we need to specify the method to use to compute ~simplex-counts~ for each ~subtarget~, and the data-type of it's output.
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*computation][computation:1]]
        computation:
          source: micasa.connsense.develop.analyze.composition.projections.projections
          method: "innervate_cells"
        output: "pandas.DataFrame"
# computation:1 ends here

# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*cross-col-k-indegree][cross-col-k-indegree:1]]
      cross-col-k-indegree:
        description: >-
          Compute generalized in-degree of nodes in adj_target from nodes in adj_source.
          The k-in-degree of a node v is the number of k-simplices in adj_source with all its nodes mapping to v
          through edges in adj_cross
        input:
          adj_cross:
            dataset: ["extract-edge-populations", "long-range-cross"]
          adj_source:
            dataset: ["extract-edge-populations", "local"]
            join_index:
              subtarget_id: pre_subtarget_id
              circuit_id: circuit_id
              connectome_id: DROP
        computation:
          source: "/gpfs/bbp.cscs.ch/project/proj83/analyses/topological-analysis-subvolumes/proj83/connectome_analysis/library/topology.py"
          method: "cross_col_k_in_degree"
        output: "pandas.DataFrame"
# cross-col-k-indegree:1 ends here

# We have defined extractions of /cross-connectivity/, which measures the amount of connectivity between ~subtargets~. This data can be large on the disc, so we may want to save aggregate values only. We can interpret this data as connectivity of a /coarse-grained/ connectome with connectivity strengths in each ~source --> target~ representing the total number of synapses from the axons starting at the neurons contained in the ~source~ sub-population on to dendrites of the neurons among the ~target~ sub-population. We define ~source~ and ~target~ sub-populations as our analysis' ~subtargets~, and aggregate ~moments~ of the values of the connection matrix containing synapse counts,
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*cross-connectivity][cross-connectivity:1]]
      cross-connectivity-local:
        description: >-
          Moments of counts of synapses between nodes across subtargets.
        input:
          pre:
            dataset: ["define-subtargets", "flatmap-columns"]
          circuit:
            - "Bio_M"
          connectome:
            - "local"
          post:
            dataset: ["define-subtargets", "flatmap-columns"]
          join: CROSS
        computation:
          source: micasa.connsense.develop.extract.edge_populations.extract_connectivity
          method: aggregate_cross_adj
        output: "pandas.Series"
# cross-connectivity:1 ends here

# for ~local~ edges and
# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*cross-connectivity][cross-connectivity:2]]
      cross-connectivity-long-range:
        description: >-
          Moments of counts of synapses between nodes across subtargets.
        input:
          pre:
            dataset: ["define-subtargets", "flatmap-columns"]
          circuit:
            - "Bio_M"
          connectome:
            - "intra_SSCX_midrange_wm"
          post:
            dataset: ["define-subtargets", "flatmap-columns"]
          join: CROSS
        computation:
          source: micasa.connsense.develop.extract.edge_populations.extract_connectivity
          method: aggregate_cross_adj
        output: "pandas.Series"
# cross-connectivity:2 ends here

# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*node-participation][node-participation:1]]
      node-participation:
        description: >-
          How many simplices does a node participate in?
        input:
          adj:
            dataset: ["extract-edge-populations", "local"]
        computation:
          source: "/gpfs/bbp.cscs.ch/project/proj83/analyses/topological-analysis-subvolumes/proj83/connectome_analysis/library/topology.py"
          method: "node_participation"
        output: "pandas.DataFrame"
# node-participation:1 ends here

# #+header: :comments both :padline no :tangle ./pipeline.yaml

# [[file:config.org::*Scratch][Scratch:1]]

# Scratch:1 ends here
