#+PROPERTY: header-args:jupyter-python :session ~/jupyter-run/active-ssh.json
#+PROPERTY: header-args:jupyter :session ~/jupyter-run/active-ssh.json

#+STARTUP: overview
#+STARTUP: logdrawer
#+STARTUP: hideblocks

Let us setup an interactive ~Python~ session where we can run the code developed here.
#+BEGIN_SRC jupyter
print("Welcome to EMACS Jupyter")
#+END_SRC

#+RESULTS:
: Welcome to EMACS Jupyter
#+title: Connsense Topology Pipeline for SSCx

We an provide a litte header for the pipeline
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
description: >-
  Configure a connsense subTarget Analysis Pipeline to analyze your circuit.
version: 0.1.0
date: <2023-02-13 Mon>
#+end_src

* paths
We need to set paths to the artefacts that the pipeline will use. We set paths for the circuit to analyze, and the root space for the pipeline's HDF5 stores, and the HDF5 group for each of the pipeline steps.
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
paths:
  description: >-
    The ~connsense~ pipeline needs paths to the input data to load from, and output paths to store data.
    Paths to the circuit must be provided along with paths to the HDF5 archive that will store the pipeline's
    results.
  format: relative
  circuit:
    root: "/gpfs/bbp.cscs.ch/project/proj83/circuits"
    files:
      Bio_M: "Bio_M/20200805/CircuitConfig_TC_WM"
  pipeline:
    root: "/gpfs/bbp.cscs.ch/project/proj83/home/sood/topological-analysis-subvolumes/test/v2"
    input:
      store: "connsense.h5"
    output:
      store: "connsense.h5"
    steps:
      define-subtargets: "subtargets"
      extract-node-populations: "nodes/populations"
      extract-edge-populations: "edges/populations"
      analyze-connectivity: "analyses/connectivity"
#+end_src

* parameters
We provide the parameters for each step.
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
parameters:
  description: >-
    Provide parameters that apply to each step.
#+end_src
The pipeline will ~define~ the ~subtargets~, ~extract~ circuit artefacts for the ~subtargets~, and ~analyze~ the results. Each of these ~steps~ need to be defined.

** define-subtargets
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
  define-subtargets:
    description: >-
      Configure the subtargets to analyze, entrying each definition as a key, value.
    definitions:
#+end_src
We define ~flatmap-columns~ which are prism like columns orientated along cortical layers, from white-matter to pia. The data is loaded from an ~NRRD~ that maps each circuit voxel to an ~id~ that corresponds to ~flatmap-column-subtarget~. We also need ~info~, a ~dataframe~ that provides information about these ~subtargets~ indexing them by the ~id~ from the ~NRRD~.
*** flatmap-columns
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
      flatmap-columns:
        description: >-
          Hexaongal prism like columns oriented along cortical layers,
          from white-matter to pia.  The data is loaded from an NRRD file that maps each
          circuit voxel to a subtarget ids corresponding to a flatmap column.The subtarget
          ids should be mapped to the subtargets they refer to in a dataframe provided as
          the input `info`.
        input:
          circuit:
          - "Bio_M"
        kwargs:
          path: "/gpfs/bbp.cscs.ch/project/proj83/home/reimann/subvolumes/column_identities.nrrd"
          info: "/gpfs/bbp.cscs.ch/project/proj83/home/reimann/subvolumes/voxel-based-hex-grid-info-with-conicality.h5"
        loader:
          source: connsense.define_subtargets.flatmap
          method: load_nrrd
#+end_src
The ~input~ is set to a label that should appear among ~config-paths~. The ~loader~ method used is expected to take a ~bluepy.Circuit~ instance as an argument, which will be passed by ~connsense~.

** create-index
Within ~connsense~ we use an ~internal~ index for ~subtarget, circuit, connectome~. While we can infer this information from [[paths]] and [[define-subtargets]], we have not yet (<2023-02-13 Mon>) implemented this feature.
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
  create-index:
    description:
      Create tap-store indices by listing datasets for each index variable.
    variables:
      circuit:
        - "Bio_M"
      connectome:
        - "local"
        - "intra_SSCX_midrange_wm"
        - "Thalamocortical_input_VPM"
        - "Thalamocortical_input_POM"
      subtarget:
        dataset: ["define-subtargets", "flatmap-columns/name"]
#+end_src
** extract-node-populations
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
  extract-node-populations:
    description: >-
      Specify the populations to extract from a circuit.
    populations:
#+end_src

*** default
The population of /non-barrel/ SSCx biophysical nodes will be the node-population that we analyze,
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
      default:
        description: >-
          The default population will be that of neurons in the SSCx.
          To extract the neurons we will use a `connsense` method that uses ~bluepy~.
        input:
          subtarget:
            dataset:  ["define-subtargets", "flatmap-columns"]
          circuit:
            - "Bio_M"
        kwargs:
          properties:
            - region
            - layer
            - x
            - y
            - z
            - depth
            - synapse_class
            - mtype
            - etype
            - morphology
        extractor:
          source: connsense.extract_nodes.bluepy
          method: extract_node_properties
        output: "pandas.DataFrame"
#+end_src
** extract-edge-populations
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
  extract-edge-populations:
    description: >-
      Specify the edge populations to extract from a circuit.
    populations:
#+end_src
We will analyze topology of the ~local~ connectome that consists of the connections among cells based on their axo-dendritic appositions. To study the local connectivity of a ~subtarget~, we will need it's adjacency matrix that we can extract to the ~TAPStore~.

*** local
The population of local connections resulting from axo-dendritic appositions,
#+name: local-edges
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
      local:
        input:
          subtarget:
            dataset:  ["define-subtargets", "flatmap-columns"]
          circuit:
            - "Bio_M"
          connectome:
            - "local"
        extractor:
          source: micasa.connsense.develop.extract.edge_populations.extract_connectivity
          method: extract_adj
        output: "sparse.spmatrix"
#+end_src

*** long-range
We can extract /long-rage/ connectivity /between/ ~flatmap-columns~ by defining computations of pairs of ~flatmap-columns~.

Our initial goal of extracting ~long-range~ connectivity is to investigate the topolgical structure of simplices whose ~source-vertex lies in a selected ~flatmap-columns~. The ~source-subtarget~  ~flatmap-columns~ that we will be interested in will be determined by their ~innervation~ from thalamo-cortical projections.

We will extract two different ~long-range~ edge-populations. The edge-population ~long-range-sources~ (of the ~flatmap-columns~) will contain a ~list(adjacency-matrix)~ for each ~flatmap-column~. For a given ~flatmap-column~ ~X~, there will be one ~adjacency-matrix~ for each of another ~flatmap-column~ ~Y~. The ~adjacency-matrix~ for ~X, Y~ will contain edges that have their ~targets~ in ~X~, and ~sources~ in ~Y~.

#+begin_src jupyter-python
def long_range_sources(flatmap_column, source_flatmap_column=None):
    """Long range sources of a flatmap-column."""
    dataset = cnstap.TapDataset(tap, ("extract-edge-populations", "long-range-sources"))
    matrices = dataset.loc[flatmap_column, 0, 0]
    return matrices if not source_flatmap_column else matrices.loc[source_flatmap_column]
#+end_src
will give us a ~pandas.Series(adjacency-matrix)~, one for each ~flatmap-column~ among a selection of ~sources~.

For ~long-range-targets~,
#+begin_src jupyter-python
def long_range_targets(flatmap_column, target_flatmap_column=None):
    """Long range targets of a flatmap-column."""
    dataset = cnstap.TapDataset(tap, ("extract-edge-populations", "long-range-targets"))
    matrices = dataset.loc[flatmap_column, 0, 0]
    return matrices if not target_flatmap_column else matrices.loc[target_flatmap_column]
#+end_src

The population ~long-range-sources~ will be of edges (represented as (CSR) directed adjacency matrices), one for each pair ~(X, Y)~ of ~flatmap-columns~. The ~edge-population~ for a ~flatmap-column~  ~X~ will have it's ~targets~ among nodes in ~X~, while the ~sources~ of the edges will be among another. The primary index in ~connsense~ will be the ~flatmap-column~ that is receiving the ~incoming~ conenctions. With ~circuit, connectome~ specified, we will have another ~input~, the ~sources~ that will specify a subset of ~flatmap-columns~ to be /crossed/ with each dataset in ~connsense-TAP~ that matches the specification of ~subtarget, circuit, connectome~ inputs,
#+name: long-range-sources
#+header: :comments both :padline no :tangle no
#+begin_src yaml
      long-range-sources:
        input:
          subtarget:
            dataset: ["define-subtargets", "flatmap-columns"]
          circuit:
            - "Bio_M"
          connectome:
            - "intra_SSCX_midrange_wm"
          sources:
            dataset: ["define-subtargets", "flatmap-columns"]
            subset: [100]
            join: CROSS
        kwargs:
          direction: "incoming"
        output: "sparse.spmatrix"
#+end_src
which pairs with ,
#+name: long-range-targets
#+header: :comments both :padline no :tangle no
#+begin_src yaml
      long-range-targets:
        input:
          subtarget:
            dataset: ["define-subtargets", "flatmap-columns"]
          circuit:
            - "Bio_M"
          connectome:
            - "intra_SSCX_midrange_wm"
          targets:
            dataset: ["define-subtargets", "flatmap-columns"]
            subset: [[100, 0]]
            join: CROSS
        kwargs:
          direction: "incoming"
        output: "sparse.spmatrix"
#+end_src

experiment with,
#+name: long-range-sources
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
      long-range-cross:
        input:
          pre:
            dataset: ["define-subtargets", "flatmap-columns"]
          circuit:
            - "Bio_M"
          connectome:
            - "intra_SSCX_midrange_wm"
          post:
            dataset: ["define-subtargets", "flatmap-columns"]
          join: CROSS
        extractor:
          source: micasa.connsense.develop.extract.edge_populations.extract_connectivity
          method: extract_cross_adj
        output: "sparse.spmatrix"
#+end_src

We can also have local cross adj,
#+name: local-cross
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
      local-cross:
        input:
          pre:
            dataset: ["define-subtargets", "flatmap-columns"]
            subset: [[100, 0], [9, 0]]
          circuit:
            - "Bio_M"
          connectome:
            - "local"
          post:
            dataset: ["define-subtargets", "flatmap-columns"]
          join: CROSS
        extractor:
          source: micasa.connsense.develop.extract.edge_populations.extract_connectivity
          method: extract_cross_adj
        output: "sparse.spmatrix"
#+end_src
**** Other possibilities

Using the concept of a ~datajoin~,
#+header: :comments both :padline no :tangle no
#+begin_src yaml
      long-range-sources:
          input:
            subtarget_pair:
              datajoin:
                pre:
                  dataset:  ["define-subtargets", "flatmap-columns"]
                  subset: [100]
                post:
                  dataset:  ["define-subtargets", "flatmap-columns"]
                how: "cross"
            circuit:
              - "Bio_M"
            connectome:
              - "intra_SSCX_midrange_wm"
          extractor:
            source: micasa.connsense.develop.extract.edge_populations.extract_connectivity
            method: extract_cross_adj
          output: "sparse.spmatrix"
#+end_src

This will require an ~extractor~ that takes ~mapping~ ~target~ and ~source~ ~flatmap-column~,
#+header: :comments both :padline no :tangle no
#+begin_src yaml
      long-range-sources:
        input:
          target:
            subtarget:
              dataset: ["define-subtargets", "flatmap-columns"]
            circuit:
              - "Bio_M"
            connectome:
              - "intra_SSCX_midrange_wm"
          source:
            subtarget:
              dataset: ["define-subtargets", "flatmap-columns"]
              subset: [100]
            circuit:
              - "Bio_M"
            connectome:
              - "intra_SSCX_midrange_wm"
          join: GRID2D
        kwargs:
          direction: "incoming"
        output: "sparse.spmatrix"


long-range-targets:
        input:
          source:
            subtarget:
              dataset: ["define-subtargets", "flatmap-columns"]
            circuit:
              - "Bio_M"
            connectome:
              - "intra_SSCX_midrange_wm"
          target:
            subtarget:
              dataset: ["define-subtargets", "flatmap-columns"]
              subset: [100]
            circuit:
              - "Bio_M"
            connectome:
              - "intra_SSCX_midrange_wm"
          join: GRID2D
        kwargs:
          direction: "incoming"
        output: "sparse.spmatrix"

#+end_src

OR
#+header: :comments both :padline no :tangle no
#+begin_src yaml
      long-range-sources:
        input:
          subtarget:
            post:
              dataset:  ["define-subtargets", "flatmap-columns"]
            pre:
              dataset:  ["define-subtargets", "flatmap-columns"]
              subset: [100]
            join: "cross"
          circuit:
            - "Bio_M"
          connectome:
            - "intra_SSCX_midrange_wm"
          join: "left"
        extractor:
          source: micasa.connsense.develop.extract.edge_populations.extract_connectivity
          method: extract_cross_adj
        output: "sparse.spmatrix"
#+end_src

It may be simpler to book keep data in ~connsense-TAP~ if we extracted ~cross-connectivity~ symmetrically.  Instead of an ~integer~ valued ~subtarget~, for these computation we will have ~subtarget_pair~ which will be a ~pair-tuple~.
#+header: :comments both :padline no :tangle no
#+begin_src yaml
      long-range:
        input:
          subtarget_pair:
            dataprod:
              - dataset: ["define-subtargets", "flatmap-columns"]
                subset: null
              - dataset: ["define-subtargets", "flatmap-columns"]
                subset: [1, 100, 31]
          circuit:
            - "Bio_M"
          connectome:
            - "intra_SSCX_midrange_wm"
        extractor:
          source: micasa.connsense.develop.extract.edge_populations.extract_connectivity
          method: extract_xadj
        output: "SeriesofSparseMatrices"
#+end_src
The main problem with this ~config~ is that the result will have subtargets in a ~pair-tuple~.

***** grid-2d
What about implementing ~connsense-inputs~ that are loaded as a ~frame~, instead of ~series~?
#+header: :comments both :padline no :tangle no
#+begin_src yaml
      long-range-outgoing
        input:
          grid2d:
            rows:
              subtarget:
                dataset: ["define-subtargets", "flatmap-columns"]
                subset: [100]
              circuit:
                - "Bio_M"
              connectome:
                - "intra_SSCX_midrange_wm"
            cols:
              subtarget:
                dataset: ["define-subtargets", "flatmap-columns"]
        extractor:
          source: micasa.connsense.develop.extract.edge_populations.extract_connectivity
          method: extract_cross_adj_outgoing
        output: scipy.sparse.spmatrix

#+end_src

** analyze-connectivity
We will analyze several phenomena related to network topology, each entered in ~analyses~,
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
  analyze-connectivity:
    description: >-
      Configure each analyses' parameters, as a mapping under section `analyses`.
    analyses:
#+end_src
*** simplex-counts
We count the number of /simplices/ that is complete subgraphs of a given dimension /i.e/ the number of edges in the simplex. So a node is a simplex of dimension 0, an edge of dimension 1 while a dimension 2 will be a triangle. We will compute a series of simplex counts by dimension for each subtarget, 5 of it's Erdos-Renyi controls, subgraphs in each layer and their ER controls.
**** description
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
      simplex-counts:
        description: >-
          Number of simplices by dimension.
#+end_src
**** input
We will compute ~simplex-counts~ for each of the ~flatmap-columns~, using ~adjacency~ matrices that we extract as dataset ~("extract-edge-populations", "local")~. We will also use ~node_properties~ that we extract as ~node-population~ ~default~.
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
        input:
          node_properties:
            dataset: ["extract-node-populations", "default"]
          adjacency:
            dataset: ["extract-edge-populations", "local"]
#+end_src
**** controls
We will use random controls for each ~subtarget~, entering them by name and value. We start with Erdos-Renyi controls, 5 of them specified by seed.
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
        controls:
          erdos-renyi:
            description: >-
              Erdos-Renyi shuffle of edges.
            seeds: [0, 1, 2, 3, 4]
            algorithm:
              source: "/gpfs/bbp.cscs.ch/project/proj83/analyses/topological-analysis-subvolumes/proj83/connectome_analysis/library/randomization.py"
              method: "ER_shuffle"
          dd2:
            description: >-
              Apply DD2, a second order distance dependent model, to rewire the circuit.
            seeds: [0, 1, 2, 3, 4]
            algorithm:
              source: "/gpfs/bbp.cscs.ch/project/proj83/analyses/topological-analysis-subvolumes/proj83/connectome_analysis/library/randomization.py"
              method: "run_DD2_model"
            tap_datasets:
              model_params_dd2: ["analyze-connectivity", "model-params-dd2"]
#+end_src
**** slicing
We will slice each ~subtarget~ into ~subtgraphs~ consisting of each of the cortical layers. Thus a single ~subtarget~ should give us 6 of these ~slicings~. To compute analysis on a ~slicing~ we will have to enter it inside the ~analysis~ config.

We may store computation of each slice of a single subtarget as a ~datacall~. This will result in each slice of each subtarget to be sequenced as a ~unit-computation~. In ~connsense-parallelization~, we then parallelize based on the sizes of all the slices. The computation is seprated from that of ~full-subtargets~. This does not work well with ~simplex-counts~ as ~datacall~ of a single ~slice~ requires us to first load the adjacency matrices, then control them. With large adjacency matrices the computation of a unit ~slice-subtarget~ will require the same resources as loading the original full and randomizing it. Instead we will have to serially compute the slices' simplex-counts for each subtarget.

We can specify this in the config as ~compute_mode: EXECUTE~, instead of ~DATACALL~ which will create individual ~datacalls~, or ~DATASET~ that should save each ~slice-subtarget~ to a ~TapDataset~.
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
        slicing:
          description: >-
            Slice analysis input according to some rules.
          do-full: true #to run the original full matrices as well...
          layer:
            description: >-
              Intralayer subgraphs.
            compute_mode: EXECUTE
            slices:
              layer: [1, 2, 3, 4, 5, 6]
            algorithm:
              source: "/gpfs/bbp.cscs.ch/project/proj83/analyses/topological-analysis-subvolumes/proj83/connectome_analysis/library/topology.py"
              method: "subgraph_intralayer"
#+end_src
**** computation
Finally, we need to specify the method to use to compute ~simplex-counts~ for each ~subtarget~, and the data-type of it's output.
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
        computation:
          source: "/gpfs/bbp.cscs.ch/project/proj83/analyses/topological-analysis-subvolumes/proj83/connectome_analysis/library/topology.py"
          method: "simplex_counts"
        output: "pandas.Series"
#+end_src

*** simplex-source-count of cross connectivity
A simplex ~s~ is /efferent/ to a node ~n~ if each of it's vertices is /efferently/ connected to ~n~. Given a ~flatmap-column~s ~X~ and ~Y~, we want to count for each node ~x~ of ~X~ the number of simplices in ~y~ that are /efferent/ to ~x~.
**** description
#+header: :comments both :padline no :tangle no
#+begin_src yaml
      long-range-simplex-sources:
        description: >-
          For each node N in flatmap-column X, count the simplices in flatmap-column Y
          that are efferent to N
#+end_src
**** input
We will compute ~simplex-counts~ for each of the ~flatmap-columns~, using ~adjacency~ matrices that we extract as dataset ~("extract-edge-populations", "local")~. We will also use ~node_properties~ that we extract as ~node-population~ ~default~.
#+header: :comments both :padline no :tangle no
#+begin_src yaml
        input:
          xadj:
            dataset: ["extract-edge-populations", "long-range/sources"]
          node_properties:
            datajoin:
              pre:
                dataset: ["extract-node-populations", "default"]
              post:
                dataset: ["extract-node-populations", "default"]
          adj:
            datajoin:
              pre:
                dataset: ["extract-edge-populations", "local"]
#+end_src
**** computation
Finally, we need to specify the method to use to compute ~simplex-counts~ for each ~subtarget~, and the data-type of it's output.
#+header: :comments both :padline no :tangle no
#+begin_src yaml
        computation:
          source: "/gpfs/bbp.cscs.ch/project/proj83/analyses/topological-analysis-subvolumes/proj83/connectome_analysis/library/topology.py"
          method: "simplex_counts"
        output: "pandas.Series"
#+end_src

*** model-params-dd2
This analysis is used to create parameters for the distance dependent connection-probablity order 2 control model.
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
      model-params-dd2:
        description: >-
          Parameters for distance dependent connectivity model of order 2.
          Note that the `coord_names` in key `kwargs:` must agree with the configuration
          of the control model that will use the results of this analysis.
#+end_src
**** input
We will compute ~simplex-counts~ for each of the ~flatmap-columns~, using ~adjacency~ matrices that we extract as dataset ~("extract-edge-populations", "local")~. We will also use ~node_properties~ that we extract as ~node-population~ ~default~.
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
        input:
          node_properties:
            dataset: ["extract-node-populations", "default"]
          adjacency:
            dataset: ["extract-edge-populations", "local"]
#+end_src
**** computation
Finally, we need to specify the method to use to compute ~simplex-counts~ for each ~subtarget~, and the data-type of it's output.
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
        computation:
          source: "/gpfs/bbp.cscs.ch/project/proj83/analyses/topological-analysis-subvolumes/proj83/connectome_analysis/library/modelling.py"
          method: "conn_prob_2nd_order_model"
        output: "pandas.DataFrame"
#+end_src
**** kwargs
The method that we will use to compute model parameters needs these parameters,
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
        kwargs:
          bin_size_um: 50
          max_range_um: 1000
          sample_size: null
          coord_names: ["x", "y", "z"]
#+end_src

*** thalamic-innervation
We will compute the number of afferent-synapses on each neuron in a ~subtarget~ from the /thalamo-cortical/ projections.
**** description
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
      thalamic-innervation:
        description: >-
          Number of thalamo-cortical synapses at each cell in a subtarget.
#+end_src
**** vpm:
***** input
We will compute ~simplex-counts~ for each of the ~flatmap-columns~, using ~adjacency~ matrices that we extract as dataset ~("extract-edge-populations", "local")~. We will also use ~node_properties~ that we extract as ~node-population~ ~default~.
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
        vpm:
          description: >-
            Thalamic innervation of a subtarget, that originates in the VPM.
          input:
            subtarget:
              dataset: ["define-subtargets", "flatmap-columns"]
            circuit:
              - "Bio_M"
            connectome:
              - "Thalamocortical_input_VPM"
#+end_src
***** computation
Finally, we need to specify the method to use to compute ~simplex-counts~ for each ~subtarget~, and the data-type of it's output.
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
          computation:
            source: micasa.connsense.develop.analyze.composition.projections.projections
            method: "innervate_cells"
          output: "pandas.Series"
#+end_src

**** pom:
***** input
We will compute ~simplex-counts~ for each of the ~flatmap-columns~, using ~adjacency~ matrices that we extract as dataset ~("extract-edge-populations", "local")~. We will also use ~node_properties~ that we extract as ~node-population~ ~default~.
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
        pom:
          description: >-
            Thalamic innervation of a subtarget, that originates in the VPM.
          input:
            subtarget:
              dataset: ["define-subtargets", "flatmap-columns"]
            circuit:
              - "Bio_M"
            connectome:
              - "Thalamocortical_input_POM"
#+end_src
***** computation
Finally, we need to specify the method to use to compute ~simplex-counts~ for each ~subtarget~, and the data-type of it's output.
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
          computation:
            source: micasa.connsense.develop.analyze.composition.projections.projections
            method: "innervate_cells"
          output: "pandas.Series"
#+end_src

*** white-matter innervation
We will compute the /amount/ of innervation of cells of each SSCx ~flatmap-column~ from sources in each other ~flatmap-column~, grouped by their ~mtype~ and ~layer~. To accompalish this, in our computation for a single (~post-synaptic~) ~flatmap-column~'s white-matter innervation we will also need the ~flatmap-column~ assigned to each (source) cell in the circuit, in addition to the source cell's properties ~mtype~ and ~layer~.

To get the cell properties we introduce the ~tap-dataset~ called ~(circuit-node-populations, default)~. This ~dataset~ is of the same nature as ~(extract-node-populations, default)~ /i.e./ a ~dataframe~ of cell-properties indexed by ~node-id~ in the ~flatmap-column~, except that instead of a number of /subtargets/ a ~circuit-node-populations~ will contain only one ~dataframe~ of ~cell-properties~ indexed by ~cell-global-id~ (a.k.a ~gid~).
**** description
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
      wm-innervation:
        description: >-
          Number of thalamo-cortical synapses at each cell in a subtarget.
#+end_src

For ~flatmap-column~ assigned to each cell we expect that we have a ~flatmap-columns/annotation~ assigned to the ~subtargets~.
***** input
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
        input:
          subtarget:
            dataset: ["define-subtargets", "flatmap-columns"]
          source_nodes:
            dataset: ["circuit-node-populations", "default"]
          circuit:
            - "Bio_M"
          connectome:
            - "intra_SSCX_midrange_wm"
        kwargs:
          summarize_source: ["subtarget"]
#+end_src

***** computation
Finally, we need to specify the method to use to compute ~simplex-counts~ for each ~subtarget~, and the data-type of it's output.
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
        computation:
          source: micasa.connsense.develop.analyze.composition.projections.projections
          method: "innervate_cells"
        output: "pandas.DataFrame"
#+end_src

*** cross-col-k-indegree
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
      cross-col-k-indegree:
        description: >-
          Compute generalized in-degree of nodes in adj_target from nodes in adj_source.
          The k-in-degree of a node v is the number of k-simplices in adj_source with all its nodes mapping to v
          through edges in adj_cross
        input:
          adj_cross:
            dataset: ["extract-edge-populations", "long-range-cross"]
          adj_source:
            dataset: ["extract-edge-populations", "local"]
            join_index:
              subtarget_id: pre_subtarget_id
              circuit_id: circuit_id
              connectome_id: DROP
        computation:
          source: "/gpfs/bbp.cscs.ch/project/proj83/analyses/topological-analysis-subvolumes/proj83/connectome_analysis/library/topology.py"
          method: "cross_col_k_in_degree"
        output: "pandas.DataFrame"
#+end_src

*** cross-connectivity
We have defined extractions of /cross-connectivity/, which measures the amount of connectivity between ~subtargets~. This data can be large on the disc, so we may want to save aggregate values only. We can interpret this data as connectivity of a /coarse-grained/ connectome with connectivity strengths in each ~source --> target~ representing the total number of synapses from the axons starting at the neurons contained in the ~source~ sub-population on to dendrites of the neurons among the ~target~ sub-population. We define ~source~ and ~target~ sub-populations as our analysis' ~subtargets~, and aggregate ~moments~ of the values of the connection matrix containing synapse counts,
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
      cross-connectivity-local:
        description: >-
          Moments of counts of synapses between nodes across subtargets.
        input:
          pre:
            dataset: ["define-subtargets", "flatmap-columns"]
          circuit:
            - "Bio_M"
          connectome:
            - "local"
          post:
            dataset: ["define-subtargets", "flatmap-columns"]
          join: CROSS
        computation:
          source: micasa.connsense.develop.extract.edge_populations.extract_connectivity
          method: aggregate_cross_adj
        output: "pandas.Series"
#+end_src
for ~local~ edges and
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
      cross-connectivity-long-range:
        description: >-
          Moments of counts of synapses between nodes across subtargets.
        input:
          pre:
            dataset: ["define-subtargets", "flatmap-columns"]
          circuit:
            - "Bio_M"
          connectome:
            - "intra_SSCX_midrange_wm"
          post:
            dataset: ["define-subtargets", "flatmap-columns"]
          join: CROSS
        computation:
          source: micasa.connsense.develop.extract.edge_populations.extract_connectivity
          method: aggregate_cross_adj
        output: "pandas.Series"
#+end_src
for ~long-range~ edges.

In our implementation we first call a method that extracts the cross adjacency. Since, this extraction has already been used in the extraction of ~long-range-cross~ population, we could have used that instead,
#+header: :comments both :padline no :tangle no
#+begin_src yaml
      cross-connectivity:
        description: >-
          Moments of counts of synapses between nodes across subtargets.
        input:
          adj:
            dataset: ["extract-edge-populations", "local-cross"]
        computation:
          source: micasa.connsense.develop.extract.edge_populations.extract_connectivity
          method: moments
        output: "pandas.Series"
#+end_src

** node-participation
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
      node-participation:
        description: >-
          How many simplices does a node participate in?
        input:
          adj:
            dataset: ["extract-edge-populations", "local"]
        computation:
          source: "/gpfs/bbp.cscs.ch/project/proj83/analyses/topological-analysis-subvolumes/proj83/connectome_analysis/library/topology.py"
          method: "node_participation"
        output: "pandas.DataFrame"
#+end_src

* Scratch
#+header: :comments both :padline no :tangle ./pipeline.yaml
#+begin_src yaml
#+end_src
