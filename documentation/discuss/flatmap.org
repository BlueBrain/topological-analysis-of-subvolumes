#+STARTUP: overview
#+STARTUP: logdrawer
#+STARTUP: hideblocks

#+PROPERTY: header-args: :eval never-export

#+PROPERTY: header-args:jupyter-python :session ~/jupyter-run/active-83-ssh.json
#+PROPERTY: header-args:jupyter: :exports both

#+PROPERTY: header-args:jupyter :session ~/jupyter-run/active-83-ssh.json
#+PROPERTY: header-args:jupyter-python: :exports both

#+PROPERTY: header-args:bash: :exports code

#+PROPERTY: header-args:elisp: :exports both

#+PROPERTY: header-args:bibtex :exports none
#+PROPERTY: header-args:bibtex :tangle "./refs.bib"
#+BIBLIOGRAPHY: "./refs.bib"
#+BIBLIOGRAPHY: "~/observations/org/resources/bibliography/refs.bib"

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,12pt]
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage{booktabs} % for much better looking tables
#+LATEX_HEADER: \usepackage{g\usepackage{babel}
#+LATEX_HEADER: \usepackage{babel}
#+LATEX_HEADER: \usepackage[up,bf,raggedright]{titlesec}
#+LATEX_HEADER: \usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
#+LATEX_HEADER: \usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
#+LATEX_HEADER: \usepackage[labelfont=bf,font=small]{caption}
#+LATEX_HEADER: \usepackage[hidelinks]{hyperref}% for adding urls
#+LATEX_HEADER: \usepackage{sectsty}
#+LATEX_HEADER: \allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
#+LATEX_HEADER: \sectionfont{\bfseries\Large\raggedright}
#+LATEX_HEADER \usepackage[natbib=true]{biblatex} \DeclareFieldFormat{apacase}{#1} \addbibresource{~/org/resources/bibliography/refs.bib}
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{amsmath}%To cleanly write equations and math text


#+OPTIONS: <:nil c:nil todo:nil H:5

Let us load the ~Python~ environment that we will need for our discussion,
#+begin_src elisp :results silent
(pyvenv-activate "~/.vmgr_repo/py39/")
#+end_src

Let us setup an interactive ~Python~ session where we can run the code developed here.
#+begin_src jupyter
print("Welcome to EMACS Jupyter")
#+end_src

#+RESULTS:
: Welcome to EMACS Jupyter

#+title: Flatmapping a Circuit

We develop methods to understand a circuit's ~flatmap~, developing them further to help us analyze a circuit's structural and physiological properties over the flatmap's physical shape. We use the ~flatmap~ to define a grid of hexagonal prisms as ~subtargets~ The ~flatmap-columns~ of radius $230\mu m$ are based on a hexagon in the ~flatmap~'s /pixel-/space. We can add the dimension of /cortical-depth/ to this ~flatspace~ to obtain hexagonal prisms. While the ~flatmap-columns~ are identically shaped in the ~flatspace~, when projected back into the ~circuit-space~ we discover /conicality/ of the ~SSCx~ owing to the larger surface area of the pia compared to it's bottom.


* Setup
In our discussion we will develop scientific concepts to measure the circuit, and implement Python functions to compute them. Here we setup a notebook template to test and explore, and the structure of a ~Python~ package for our methods.

To get the notebook you will have to clone,
#+BEGIN_SRC shell
git clone https://bbpgitlab.epfl.ch/conn/structural/topological-analysis-of-subvolumes.git
git checkout beta
#+END_SRC

#+NAME: notebook-init
#+BEGIN_SRC jupyter-python :results silent
from importlib import reload
from collections.abc import Mapping
from collections import OrderedDict
from pprint import pprint, pformat
from pathlib import Path

import numpy as np
import pandas as pd

import matplotlib

reload(matplotlib)
from matplotlib import pylab as plt
import seaborn as sbn

from IPython.display import display

from bluepy import Synapse, Cell, Circuit

import conntility
from conntility.circuit_models.neuron_groups import group_by_grid
from conntility.flatmapping import supersample_flatmap

GOLDEN = (1. + np.sqrt(5.))/2.
print("We will plot golden aspect ratios: ", GOLDEN)
#+END_SRC

** Workspaces
We have run ~connsense-CRAP~ for the SSCx dissemination variant /Bio-M/, extracting data that we will use to compute the factology. Here is a list of workspaces we will need to generate factsheets.
#+NAME: notebook-workspaces
#+BEGIN_SRC jupyter-python :results silent
ROOTSPACE = Path("/")
PROJSPACE = ROOTSPACE / "gpfs/bbp.cscs.ch/project/proj83"
SOODSPACE = PROJSPACE / "home/sood"
CONNSPACE = SOODSPACE / "topological-analysis-subvolumes/test/v2"
DEVSPACE  = CONNSPACE / "test" / "develop"
#+END_SRC

Let us also save the figures in a local directory,
#+begin_src shell :results silent
mkdir -p ./figures/flatmap
#+end_src

** ~connsense~ Modules
While test-developing it will be good to have direct access to the ~connsense-TAP-store~ we will use. We will use a module from ~connsense~ to load the HDFstore,
#+NAME: notebook-connsense-tap
#+BEGIN_SRC jupyter-python
from connsense.develop import topotap as cnstap
tap = cnstap.HDFStore(CONNSPACE/"pipeline.yaml")
circuit = tap.get_circuit("Bio_M")
print("Available analyses: ")
pprint(tap.analyses)
circuit
#+END_SRC

#+RESULTS: notebook-connsense-tap
:RESULTS:
:  2023-07-20 10:02:09,657: Load circuit Bio_M
: Available analyses:
: {'connectivity': {'cross-col-k-indegree': <connsense.develop.topotap.TapDataset object at 0x7fff145454f0>,
:                   'model-params-dd2': <connsense.develop.topotap.TapDataset object at 0x7fff14545190>,
:                   'node-participation': <connsense.develop.topotap.TapDataset object at 0x7fff145455b0>,
:                   'simplex-counts': <connsense.develop.topotap.TapDataset object at 0x7fffbb6a9100>,
:                   'thalamic-innervation': <connsense.develop.topotap.TapDataset object at 0x7fff14545400>,
:                   'wm-innervation': <connsense.develop.topotap.TapDataset object at 0x7fff14545340>}}
: <bluepy.circuit.Circuit at 0x7fffbb6a9e50>
:END:


** Emacs specific :noexport:
We can get all figures displayed 95% so that we can work with them in front of us in an Emacs buffer. Here is a method that does that witb an example. This code is here only to see how much we use it. It should find a way to a place in our ~doom-config~.

#+NAME: fit-display-defun
#+BEGIN_SRC emacs-lisp :results silent
(defun fit-display-of (figure width height)
    (concat "#+attr_org: :width " width " :height " height (string ?\n) figure))
#+END_SRC

#+NAME: plot-display
#+HEADER: :var figure="this-should-be-path.png" :var width="95%" :var height="95%"
#+BEGIN_SRC emacs-lisp :results silent
(fit-display-of figure width height)
#+END_SRC

That we can use with ~:post~,
#+name: test-plot-display
#+HEADER: :results value file :file ./test-fit-fig.png
#+HEADER: :exports both :session return
#+HEADER: :post plot-display(figure=*this*)
#+BEGIN_SRC jupyter-python :post plot-display(figure=*this*)
import pandas as pd
from matplotlib import pyplot as plt
import seaborn as sbn

csv_url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data'
col_names = ['Sepal_Length','Sepal_Width','Petal_Length','Petal_Width','Class']
irisies = pd.read_csv(csv_url, names=col_names)

fig = plt.figure(figsize=(15, 12))
ax = sbn.histplot(x="Petal_Length", hue="Class", data=irisies, ax=fig.add_subplot())
#+END_SRC

#+RESULTS: test-plot-display
#+attr_org: :width 95% :height 95%
[[file:./test-fit-fig.png]]

We can also ~wrap~ with a function,
#+BEGIN_SRC emacs-lisp :results silent
(defun display-fig (&optional label caption attributes)
  "A wrap function for src blocks."
  (concat
   "ORG\n"
   "#+attr_org: :width 95%\n"
   "#+attr_html: :width 95%\n"
   "#+attr_latex: :width 95%\n"
   (when caption
     (format "#+CAPTION: %s\n" caption))
   (when label
     (format "#+NAME: %s" label))
   (when caption
     (format "#+caption: %s" caption))))
#+END_SRC

and use it with ~:wrap~,
#+HEADER: :wrap (display-fig "fig-sin" "A sin wave.")
#+name: figure-sin-wave
#+BEGIN_SRC jupyter-python
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path

x = np.linspace(0, 4 * np.pi, 1000)
y = np.sin(x)

fig = plt.figure(figsize=(15, 12))
axes = plt.plot(x, y)
p = Path.home() / 'work/workspaces/scratch/sin.png'
#plt.savefig(p)
#+END_SRC

#+RESULTS: figure-sin-wave
#+begin_ORG
#+attr_org: :width 95%
#+attr_html: :width 95%
#+attr_latex: :width 95%
#+CAPTION: A sin wave.
#+NAME: fig-sin#+caption: A sin wave.
[[file:./.ob-jupyter/2b5f030950050e88d31b69a9e93fb0c7f0a4000e.png]]
#+end_ORG

#+NAME: fit-display
#+HEADER: :var figure="" :var attr_value="95%" :var attr_name="#+attr_html: :width "
#+BEGIN_SRC emacs-lisp
(concat attr_name attr_value (string ?\n) figure)
#+END_SRC

#+RESULTS: fit-display
: #+attr_html: :width 95%

#+NAME: attr-wrap
#+BEGIN_SRC sh :var figure="" :var width="95%" :results output
echo "#+attr_html: :width $width"
echo "$figure"
#+END_SRC

#+RESULTS: attr-wrap
: #+attr_html: :width 95%
:

* Introduction

For the SSCx we have defined ~connsense-subtargets~ to be the ~flatmap-columns~ using a ~.nrrd~ file along with a file that provides information about the ~flatmap~ location of each ~column~. We can combine this information to plot a /grid/ of the ~flatmap~ summarizing measurements of the columns by color, shape, or size. Let us start by number of cells in a single column.

While we have the ~gids~ for each ~flatmap-column-subtarget~ in ~tap~, we can use a function that annotates each cell by the ~subtarget~ it is in, and the ~node_id~ within that ~subtarget~ assigned to it,
#+NAME: flatmap-column-assignment
#+HEADER: :comments both :padline yes :tangle ./tapestry.py :results silent
#+BEGIN_SRC jupyter-python
def assign_subtargets(tap):
    """..."""
    def series(of_gids):
        return pd.Series(of_gids, name="gid",
                         index=pd.RangeIndex(0, len(of_gids), 1, name="node_id"))
    return (pd.concat([series(gs) for gs in tap.subtarget_gids], axis=0,
                      keys=tap.subtarget_gids.index)
            .reset_index().set_index("gid"))
#+END_SRC

Thus we have
#+begin_src jupyter-python :tangle no
subtarget_assignment = assign_subtargets(tap)
display(subtarget_assignment)
#+end_src

#+RESULTS:
:RESULTS:
: /tmp/ipykernel_164353/1405977891.py:4: DeprecationWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.
:   return pd.Series(of_gids, name="gid",
#+begin_example
         subtarget_id  circuit_id  node_id
gid
1636113             1           0        0
996599              1           0        1
3524820             1           0        2
14591               1           0        3
4075085             1           0        4
...               ...         ...      ...
3198996           238           0        8
3163752           238           0        9
2922369           238           0       10
3064476           238           0       11
651271            239           0        0

[3979210 rows x 3 columns]
#+end_example
:END:

We can count the number of subtargets,
#+begin_src jupyter
subtarget_sizes = subtarget_assignment.groupby("subtarget_id").size().rename("ncells")
display(subtarget_sizes)
#+end_src

#+RESULTS:
#+begin_example
subtarget_id
1       4570
2       1823
3      17981
4       5597
5       7208
       ...
235      971
236      228
237      345
238       12
239        1
Name: ncells, Length: 239, dtype: int64
#+end_example

Using ~flatmap_utility.hexgrid~ we can get a ~flatmap~ location for each ~cell~,
#+begin_src jupyter-python
from flatmap_utility import hexgrid
fmap = hexgrid.get_flatmap(circuit)
display(fmap)
#+end_src

#+RESULTS:
:RESULTS:
: /gpfs/bbp.cscs.ch/project/proj83/analyses/topological-analysis-subvolumes/proj83/topological-analysis-of-subvolumes/flatmap_utility/flatmap_utility.py:199: UserWarning: Optimal rotation is not uniquely or poorly defined for the given sets of vectors.
:   res = Rotation.align_vectors(vtgt, vv)
: Rotation errors: min: 0.0, median: 0.09387602600937707, mean: 0.1362824184485066, std: 0.15664142313770807, max: 2.0
#+begin_example
                   x            y
gid
1        2070.254580  2941.901129
2        2716.594415  2687.716832
3        1383.068384  1163.944134
4        1265.374093  1331.794667
5        2228.382838  4131.306090
...              ...          ...
4234925  2402.376474   534.494432
4234926  5337.546887  3190.549809
4234927   773.076963  6266.401067
4234928  1469.443366  4804.540715
4234929   207.636525  1589.479125

[3979592 rows x 2 columns]
#+end_example
:END:

We also have information about the subtargets,
#+begin_src jupyter-python
tap.subtargets
#+end_src

#+RESULTS:
#+begin_example
             subtarget  flat_i  flat_j        flat_x  flat_y  conicality  \
subtarget_id
1               R18;C0     -27      27  3.802528e-13  6210.0         NaN
2               R19;C0     -28      29  1.991858e+02  6555.0         NaN
3               R18;C1     -26      28  3.983717e+02  6210.0   -0.001376
4               R19;C1     -27      30  5.975575e+02  6555.0         NaN
5               R16;C0     -24      24  3.380025e-13  5520.0         NaN
...                ...     ...     ...           ...     ...         ...
236             R4;C12       6      18  4.780460e+03  1380.0         NaN
237             R9;C15       2      29  6.174761e+03  3105.0         NaN
238            R15;C13      -9      36  5.378018e+03  5175.0         NaN
239             R3;C11       7      16  4.581274e+03  1035.0         NaN
240            R15;C15      -7      38  6.174761e+03  5175.0         NaN

                    volume       height
subtarget_id
1                      NaN          NaN
2                      NaN          NaN
3             2.049209e+08  1640.357801
4                      NaN          NaN
5                      NaN          NaN
...                    ...          ...
236                    NaN          NaN
237                    NaN          NaN
238                    NaN          NaN
239                    NaN          NaN
240                    NaN          NaN

[240 rows x 8 columns]
#+end_example

We can get positions for each subtarget from this info,
#+begin_src jupyter-python
flat_xy = ["flat_x", "flat_y"]
subtarget_positions = tap.subtargets[flat_xy]
display(subtarget_positions)
#+end_src

#+RESULTS:
:RESULTS:
:  2023-08-10 19:35:58,057: Load dataset ('define-subtargets', 'flatmap-columns'):
: ('Hexaongal prism like columns oriented along cortical layers, from '
:  'white-matter to pia.  The data is loaded from an NRRD file that maps each '
:  'circuit voxel to a subtarget ids corresponding to a flatmap column.The '
:  'subtarget ids should be mapped to the subtargets they refer to in a '
:  'dataframe provided as the input `info`.')
#+begin_example
                    flat_x  flat_y
subtarget_id
1             3.802528e-13  6210.0
2             1.991858e+02  6555.0
3             3.983717e+02  6210.0
4             5.975575e+02  6555.0
5             3.380025e-13  5520.0
...                    ...     ...
236           4.780460e+03  1380.0
237           6.174761e+03  3105.0
238           5.378018e+03  5175.0
239           4.581274e+03  1035.0
240           6.174761e+03  5175.0

[240 rows x 2 columns]
#+end_example
:END:

Now we can put together a map showing sizes of each column,

#+header: :file ./figures/flatmap/flatmap_columns.png
#+header: :wrap (display-fig "Circuit flatmap" "Each hexagonal column shown has a size proportional to the number of neurons it contains.")
#+begin_src jupyter-python
from flatmap_utility import tessellate
reload(tessellate); reload(hexgrid)
tritille_r230 = tessellate.TriTille(230.)

fig = plt.figure(figsize=(12, 12))
ax = fig.add_subplot(111, aspect=1.)

fpos = (subtarget_positions.rename(columns={"flat_x": "x", "flat_y": "y"})
        .join(subtarget_sizes))
graphic = tritille_r230.plot_hextiles(fpos[ ["x", "y"] ], graphic=(fig, ax),
                                      annotate=False, with_grid=False,
                                      pointmarker="h",
                                      pointmarkersize=700*fpos.ncells / fpos.ncells.mean())
#+end_src

#+RESULTS:
#+begin_ORG
#+attr_org: :width 95%
#+CAPTION: Each hexagonal column shown has a size proportional to the number of neurons it contains.
#+NAME: Circuit flatmap
[[file:./figures/flatmap/flatmap_columns.png]]
#+end_ORG


* Subtargets
We want to produce grids in the flatmap to generate atlas ~subvolumes~, that will define a ~subtarget~ of the circuit that we can analyze either independently, or in interaction with the other ~subtargets~. We will discuss how to generate grids in a 2D space in the next section. Here we focus on the resulting ~subtargets~.

We have defined a hexagonal grid in ~conntility~ that we can use to generate a ~hexgrid~ for the circuit's atlas. Here we develop on MR's code to generate /grid/ subtargets of a given size.

* Grids
* White matter innervation

To characterize the ~flatmap-column~ to ~flatmap-column~ via the white-matter, we have computed the dataset ~analyze-connectivity, wm-innervation~,
#+begin_src jupyter-python
wm_innervation_dset = cnstap.TapDataset(tap, ("analyze-connectivity", "wm-innervation"))
display(wm_innervation_dset.dataset)
#+end_src

#+RESULTS:
:RESULTS:
:  2023-04-11 16:21:23,976: Pour analyses for analyze-connectivity quantity wm-innervation
:  2023-04-11 16:21:23,978: Initialize a DataFrameStore matrix store loading / writing data at /gpfs/bbp.cscs.ch/project/proj83/home/sood/topological-analysis-subvolumes/test/v2/connsense.h5 / analyses/connectivity/wm-innervation
#+begin_example
subtarget_id  circuit_id  connectome_id
1             0           1                <connsense.develop.parallelization.DataCall ob...
2             0           1                <connsense.develop.parallelization.DataCall ob...
3             0           1                <connsense.develop.parallelization.DataCall ob...
4             0           1                <connsense.develop.parallelization.DataCall ob...
5             0           1                <connsense.develop.parallelization.DataCall ob...
                                                                 ...
235           0           1                <connsense.develop.parallelization.DataCall ob...
236           0           1                <connsense.develop.parallelization.DataCall ob...
237           0           1                <connsense.develop.parallelization.DataCall ob...
238           0           1                <connsense.develop.parallelization.DataCall ob...
239           0           1                <connsense.develop.parallelization.DataCall ob...
Length: 239, dtype: object
#+end_example
:END:

In the dataset we have for each target ~flatmap-column~,
#+begin_src jupyter-python
innervation_subtarget_0 = wm_innervation_dset.dataset.iloc[0]()
display(innervation_subtarget_0)
#+end_src

#+RESULTS:
#+begin_example
                         0  1  2
source_subtarget target
R17;C0           42      3  3  3
                 444     3  3  3
                 664     6  6  6
                 950     1  1  1
                 2124    1  1  1
...                     .. .. ..
R9;C7            4151    1  1  1
                 4199    1  1  1
                 4284    1  1  1
                 4365    1  1  1
                 4387    1  1  1

[66936 rows x 3 columns]
#+end_example
we have first three moments of number of synapses for each ~source_subtarget~ (/i.e./ source ~flatmap-column~) to ~target~'s ~node-id~ in a given (target) ~flatmap-column~. Thus to obtain total innervation we can,
#+begin_src jupyter-python
innervation_subtarget_0.groupby("source_subtarget")[0].sum().rename("number_edges")
#+end_src

#+RESULTS:
#+begin_example
source_subtarget
R17;C0        20
R17;C3         4
R17;C4         3
R18;C0        67
R18;C1     15275
R18;C2    597144
R18;C3     78097
R18;C4      2778
R18;C5       101
R19;C0       208
R19;C1    214547
R19;C2     75519
R19;C3      1340
R19;C4        13
R1;C1          1
R2;C1      26782
R2;C2        197
R3;C0      74663
R3;C1     350116
R3;C2      12176
R4;C0        936
R4;C1     383261
R4;C2     228195
R4;C3       1319
R5;C0       3634
R5;C1      37671
R5;C2      58858
R5;C3        407
R5;C5        130
R5;C6        332
R5;C7          5
R6;C0          7
R6;C1       2415
R6;C2       2655
R6;C3        413
R6;C4         61
R6;C6      11623
R6;C7       1665
R6;C8         27
R6;C9          1
R7;C0         27
R7;C1        666
R7;C2        152
R7;C5       1199
R7;C6      16453
R7;C7       1427
R7;C8         49
R7;C9          3
R8;C1         35
R8;C2        207
R8;C3          1
R8;C6       1600
R8;C7       2920
R8;C8        368
R8;C9         13
R9;C2          1
R9;C6         43
R9;C7         63
Name: number_edges, dtype: int64
#+end_example

We can then obtain a /CSR/ like connectivity matrix from ~source_subtargets~ to ~target_subtargets~,
#+begin_src jupyter-python
wm_innervation = (wm_innervation_dset.dataset
                  .apply(lambda l: l().groupby("source_subtarget")[0].sum())
                  .fillna(0.))
wm_innervation.index = pd.Index(tap.subtargets.subtarget
                                .loc[wm_innervation.index
                                     .get_level_values("subtarget_id")])
wm_innervation = wm_innervation.sort_index(axis=0).sort_index(axis=1)

wm_innervation
#+end_src

#+RESULTS:
#+begin_example
source_subtarget  R0;C10  R0;C11  R0;C12  R0;C3  R0;C4  R0;C5   R0;C6  \
subtarget
R0;C10               0.0     0.0     0.0    0.0    0.0    0.0     0.0
R0;C11               0.0     0.0     0.0    0.0    0.0    0.0     0.0
R0;C12               0.0     0.0     0.0    0.0    0.0    0.0     0.0
R0;C3                0.0     0.0     0.0    0.0    0.0    0.0     0.0
R0;C4                0.0     0.0     0.0    0.0    0.0    0.0     0.0
...                  ...     ...     ...    ...    ...    ...     ...
R9;C4                0.0     0.0     0.0    0.0    0.0    0.0  4323.0
R9;C5                0.0     3.0     0.0    0.0    0.0    0.0  1070.0
R9;C6                0.0     0.0     0.0    0.0    0.0    0.0     6.0
R9;C7                0.0     0.0     0.0    4.0    0.0    0.0     0.0
R9;C8                0.0     0.0     0.0    0.0    0.0    0.0     0.0

source_subtarget     R0;C7   R0;C8  R0;C9  ...    R9;C12    R9;C13  R9;C14  \
subtarget                                  ...
R0;C10                 0.0     0.0    0.0  ...       0.0       0.0     0.0
R0;C11                 0.0     0.0    0.0  ...       0.0       0.0     0.0
R0;C12                 0.0     0.0    0.0  ...       0.0       0.0     0.0
R0;C3                  0.0     0.0    0.0  ...       0.0       0.0     0.0
R0;C4                  0.0     0.0    0.0  ...       0.0       0.0     0.0
...                    ...     ...    ...  ...       ...       ...     ...
R9;C4             179563.0  1460.0    0.0  ...    2765.0     333.0     0.0
R9;C5             149426.0  8233.0    0.0  ...  481441.0   78739.0     0.0
R9;C6                287.0   205.0    1.0  ...  200248.0  184691.0    17.0
R9;C7                  2.0     0.0    0.0  ...     185.0     272.0     0.0
R9;C8                  0.0     0.0    0.0  ...       0.0       0.0     0.0

source_subtarget  R9;C15  R9;C2  R9;C3  R9;C4  R9;C5  R9;C6   R9;C7
subtarget
R0;C10               0.0    0.0    0.0    0.0    0.0    0.0     0.0
R0;C11               0.0    0.0    0.0    0.0    0.0    0.0     0.0
R0;C12               0.0    0.0    0.0    0.0    0.0    0.0     0.0
R0;C3                0.0    0.0    0.0    0.0    0.0  243.0  6192.0
R0;C4                0.0    0.0    0.0    0.0    0.0    0.0   224.0
...                  ...    ...    ...    ...    ...    ...     ...
R9;C4                0.0    0.0    0.0    0.0    0.0    0.0     0.0
R9;C5                0.0    0.0    0.0    0.0    0.0    0.0     0.0
R9;C6                0.0    0.0    0.0    0.0    0.0    0.0     0.0
R9;C7                0.0    0.0    0.0    0.0    0.0    0.0     0.0
R9;C8                0.0    0.0    0.0    0.0    0.0    0.0     0.0

[239 rows x 236 columns]
#+end_example

We can plot a heatmap for the ~flatmap-column~ to ~flatmap-column~ data above,

#+begin_src jupyter-python
fig_wmx = plt.figure(figsize=(15, 15))
ax_wmx = fig_wmx.add_subplot()
img = ax_wmx.imshow(wm_innervation.values)
#+end_src

#+RESULTS:
#+attr_html: :width 95%
[[file:./.ob-jupyter/9e346b3f61e05b54da69f29b5983ae4472b28cdb.png]]

We can sum white-matter innervation matrix across the rows to obtain the total number of white-matter connections incoming to ~subtarget~ in the columns,

#+HEADER: :post plot-display(*this*)
#+begin_src jupyter-python
fig_incoming = plt.figure(figsize=(15, 15))
ax_incoming = fig_incoming.add_subplot()

incoming = wm_innervation.sum(axis=0).rename("incoming")
incoming.index = pd.Index(tap.index_variable("subtarget").loc[incoming.index.values],
                          name="subtarget_id")
fposo = fpos.join(incoming)
XY = ["x", "y"]
size_incoming = 400 * fposo.incoming/fposo.incoming.mean()
gpic_incoming = (tritille_r230
                 .plot_hextiles(fposo[XY],
                                graphic=(fig_incoming, ax_incoming),
                                annotate=False, with_grid=True, grid_point_size=20,
                                pointmarker="h",
                                pointmarkersize=size_incoming))
#+end_src

#+RESULTS:
#+attr_html: :width 95% :height 95%
[[file:./.ob-jupyter/e05bcf025a8bf640eb727bb019e67cbcc5bf91e8.png]]

We can also plot the outgoing innervation
#+HEADER: :post plot-display(*this*)
#+begin_src jupyter-python
fig_outgoing = plt.figure(figsize=(15, 15))
ax_outgoing = fig_outgoing.add_subplot()

outgoing = wm_innervation.sum(axis=1).rename("outgoing")
outgoing.index = pd.Index(tap.index_variable("subtarget").loc[outgoing.index.values],
                          name="subtarget_id")
fposo = fpos.join(outgoing)
XY = ["x", "y"]
size_outgoing = 600 * fposo.outgoing/fposo.outgoing.mean()
gpic_outgoing = (tritille_r230
                 .plot_hextiles(fposo[XY],
                                graphic=(fig_outgoing, ax_outgoing),
                                annotate=False, with_grid=True, grid_point_size=20,
                                pointmarker="h",
                                pointmarkersize=size_outgoing))
#+end_src

#+RESULTS:
#+attr_html: :width 95% :height 95%
[[file:./.ob-jupyter/b4e1c49e517ef900cdcb718b98955b838a879d7f.png]]

We can also plot the /map/ of incoming or outgoing innervation,
#+begin_src jupyter-python
def plot_outgoing_innervation(flatmap_column):
    """..."""
    outgoing = wm_innervation.loc[flatmap_column, :].rename("outgoing")
    outgoing.index = pd.Index(tap.index_variable("subtarget").loc[outgoing.index.values],
                              name="subtarget_id").fillna(0.)
    fposo = fpos.join(outgoing)

    fig = plt.figure(figsize=(15, 15))
    ax = fig.add_subplot()

    XY = ["x", "y"]
    size_outgoing = 20 * fposo.outgoing/fposo.outgoing.mean()
    graphic = (tritille_r230
               .plot_hextiles(fposo[XY],
                              graphic=(fig, ax),
                              annotate=False, with_grid=True, grid_point_size=20,
                              pointmarker="h",
                              pointmarkersize=size_outgoing))
    return graphic
#+end_src

So for the subtarget (100, 0)
#+HEADER: :post plot-display(*this*)
#+begin_src jupyter-python
g_out_100 = plot_outgoing_innervation("R7;C3")
#+end_src

#+RESULTS:
#+attr_html: :width 95% :height 95%
[[file:./.ob-jupyter/8a92de06db225d7a3b24e8eb7af926c164dfe286.png]]

And for incoming
#+begin_src jupyter-python
def plot_incoming_innervation(flatmap_column):
    """..."""
    incoming = wm_innervation.loc[:, flatmap_column].rename("incoming")
    incoming.index = pd.Index(tap.index_variable("subtarget").loc[incoming.index.values],
                              name="subtarget_id").fillna(0.)
    fposo = fpos.join(incoming)

    fig = plt.figure(figsize=(15, 15))
    ax = fig.add_subplot()

    XY = ["x", "y"]
    size_incoming = 20 * fposo.incoming/fposo.incoming.mean()
    graphic = (tritille_r230
               .plot_hextiles(fposo[XY],
                              graphic=(fig, ax),
                              annotate=False, with_grid=True, grid_point_size=20,
                              pointmarker="h",
                              pointmarkersize=size_incoming))
    return graphic
#+end_src

#+RESULTS:

#+HEADER: :post plot-display(*this*)
#+begin_src jupyter-python
g_in_100 = plot_incoming_innervation("R7;C3")
#+end_src
#+attr_html: :width 95% :height 95%
[[file:./.ob-jupyter/d139054aedf4d542e8b19815d32d546a06c8068e.png]]

We can also ~cross-col-k-indegree~,
#+begin_src jupyter-python
cckin  = ("analyze-connectivity", "cross-col-k-indegree")

dsetcckin = cnstap.TapDataset(tap, cckin, belazy=False)

cross_col_k_indegree = pd.concat(dsetcckin.dataset.values,
                                 keys=dsetcckin.dataset.index).fillna(0)
display(cross_col_k_indegree)
#+end_src

#+RESULTS:
:RESULTS:
:  2023-04-11 18:28:38,825: Pour analyses for analyze-connectivity quantity cross-col-k-indegree
:  2023-04-11 18:28:38,827: Initialize a DataFrameStore matrix store loading / writing data at /gpfs/bbp.cscs.ch/project/proj83/home/sood/topological-analysis-subvolumes/test/v2/connsense.h5 / analyses/connectivity/cross-col-k-indegree
#+begin_example
dim                                                                1    2  \
pre_subtarget_id post_subtarget_id circuit_id connectome_id 0
9                1                 0          1             20811  0  0.0
                                                            20812  0  0.0
                                                            20813  0  0.0
                                                            20814  0  0.0
                                                            20815  0  0.0
...                                                               ..  ...
119              238               0          1             23383  0  0.0
                                                            23384  0  0.0
                                                            23385  0  0.0
                                                            23386  0  0.0
                 239               0          1             23375  0  0.0

dim                                                                  3    4  \
pre_subtarget_id post_subtarget_id circuit_id connectome_id 0
9                1                 0          1             20811  0.0  0.0
                                                            20812  0.0  0.0
                                                            20813  0.0  0.0
                                                            20814  0.0  0.0
                                                            20815  0.0  0.0
...                                                                ...  ...
119              238               0          1             23383  0.0  0.0
                                                            23384  0.0  0.0
                                                            23385  0.0  0.0
                                                            23386  0.0  0.0
                 239               0          1             23375  0.0  0.0

dim                                                                  5    6
pre_subtarget_id post_subtarget_id circuit_id connectome_id 0
9                1                 0          1             20811  0.0  0.0
                                                            20812  0.0  0.0
                                                            20813  0.0  0.0
                                                            20814  0.0  0.0
                                                            20815  0.0  0.0
...                                                                ...  ...
119              238               0          1             23383  0.0  0.0
                                                            23384  0.0  0.0
                                                            23385  0.0  0.0
                                                            23386  0.0  0.0
                 239               0          1             23375  0.0  0.0

[31833680 rows x 6 columns]
#+end_example
:END:
And to plot,
#+begin_src jupyter-python
def plot_cross_column_k_indegree(flatmap_column, k=3):
    """..."""

    fposs = fpos.join(cross_col_k_indegree.loc[flatmap_column]
                      .groupby("post_subtarget_id")[k].sum()
                      .rename("cross_col_k_indegree"))

    fig = plt.figure(figsize=(15, 15))
    ax = fig.add_subplot()

    XY = ["x", "y"]
    size_indegree = (20 *
                     fposs.cross_col_k_indegree
                     /fposs.cross_col_k_indegree[fposs.cross_col_k_indegree > 0].mean())
    graphic = (tritille_r230
               .plot_hextiles(fposo[XY],
                              graphic=(fig, ax),
                              annotate=False, with_grid=True, grid_point_size=10,
                              pointmarker="h",
                              pointmarkersize=size_indegree))
    return graphic
#+end_src

#+RESULTS:
