#+STARTUP: overview
#+STARTUP: logdrawer
#+STARTUP: hideblocks

#+PROPERTY: header-args: :eval never-export

#+PROPERTY: header-args:jupyter-python :session ~/jupyter-run/active-83-ssh.json
#+PROPERTY: header-args:jupyter: :exports both

#+PROPERTY: header-args:jupyter :session ~/jupyter-run/active-83-ssh.json
#+PROPERTY: header-args:jupyter-python: :exports both

#+PROPERTY: header-args:bash: :exports code

#+PROPERTY: header-args:elisp: :exports both

#+PROPERTY: header-args:bibtex :exports none
#+PROPERTY: header-args:bibtex :tangle "./refs.bib"
#+BIBLIOGRAPHY: "./refs.bib"
#+BIBLIOGRAPHY: "~/observations/org/resources/bibliography/refs.bib"

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,12pt]
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage{booktabs} % for much better looking tables
#+LATEX_HEADER: \usepackage{g\usepackage{babel}
#+LATEX_HEADER: \usepackage{babel}
#+LATEX_HEADER: \usepackage[up,bf,raggedright]{titlesec}
#+LATEX_HEADER: \usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
#+LATEX_HEADER: \usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
#+LATEX_HEADER: \usepackage[labelfont=bf,font=small]{caption}
#+LATEX_HEADER: \usepackage[hidelinks]{hyperref}% for adding urls
#+LATEX_HEADER: \usepackage{sectsty}
#+LATEX_HEADER: \allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
#+LATEX_HEADER: \sectionfont{\bfseries\Large\raggedright}
#+LATEX_HEADER \usepackage[natbib=true]{biblatex} \DeclareFieldFormat{apacase}{#1} \addbibresource{~/org/resources/bibliography/refs.bib}
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{amsmath}%To cleanly write equations and math text


#+OPTIONS: <:nil c:nil todo:nil H:5

Let us load the ~Python~ environment that we will need for our discussion,
#+begin_src elisp :results silent
(pyvenv-activate "~/.vmgr_repo/py39/")
#+end_src

Let us setup an interactive ~Python~ session where we can run the code developed here.
#+begin_src jupyter
print("Welcome to EMACS Jupyter")
#+end_src

#+RESULTS:
: Welcome to EMACS Jupyter


#+title: Topological analyses of brain circuits

We develop topological analyses of brain circuits, and implement ~Python~ code that we can use with to configure a ~connsense-pipeline~. Instead of the connectivity of the whole circuit /Mosaic/, our focus will be ~circuit-subtargets~ that are geometrically defined. We will start by describing how to configure a ~connsense-pipeline~, run it, and use ~connsensnse-tap~ to access and analyze the data.

* Setup
In our discussion we will develop scientific concepts to measure the circuit, and implement Python functions to compute them. Here we setup a notebook template to test and explore, and the structure of a ~Python~ package for our methods.

To get the notebook you will have to clone,
#+BEGIN_SRC shell
git clone https://bbpgitlab.epfl.ch/conn/structural/topological-analysis-of-subvolumes.git
git checkout beta
#+END_SRC

#+NAME: notebook-init
#+BEGIN_SRC jupyter-python
from importlib import reload
from collections.abc import Mapping
from collections import OrderedDict
from pprint import pprint, pformat
from pathlib import Path

import numpy as np
import pandas as pd

import matplotlib

reload(matplotlib)
from matplotlib import pylab as plt
import seaborn as sbn

from IPython.display import display

from bluepy import Synapse, Cell, Circuit

GOLDEN = (1. + np.sqrt(5.))/2.
print("We will plot golden aspect ratios: ", GOLDEN)
#+END_SRC

#+RESULTS: notebook-init
: We will plot golden aspect ratios:  1.618033988749895

** Workspaces
We have run ~connsense-CRAP~ for the SSCx dissemination variant /Bio-M/, extracting data that we will use to compute the factology. Here is a list of workspaces we will need to generate factsheets.
#+NAME: notebook-workspaces
#+BEGIN_SRC jupyter-python
ROOTSPACE = Path("/")
PROJSPACE = ROOTSPACE / "gpfs/bbp.cscs.ch/project/proj83"
SOODSPACE = PROJSPACE / "home/sood"
CONNSPACE = SOODSPACE / "topological-analysis-subvolumes/test/v2"
DEVSPACE  = CONNSPACE / "test" / "develop"
#+END_SRC

#+RESULTS: notebook-workspaces

** ~connsense~ Modules
While test-developing it will be good to have direct access to the ~connsense-TAP-store~ we will use. We will use a module from ~connsense~ to load the HDFstore,
#+NAME: notebook-connsense-tap
#+BEGIN_SRC jupyter-python
from connsense.develop import topotap as cnstap
tap = cnstap.HDFStore(CONNSPACE/"pipeline.yaml")
circuit = tap.get_circuit("Bio_M")
print("Available analyses: ")
pprint(tap.analyses)
circuit
#+END_SRC

#+RESULTS: notebook-connsense-tap
:RESULTS:
:  2023-07-03 13:33:45,669: Load circuit Bio_M
: Available analyses:
: {'connectivity': {'cross-col-k-indegree': <connsense.develop.topotap.TapDataset object at 0x7ffee4f8c070>,
:                   'model-params-dd2': <connsense.develop.topotap.TapDataset object at 0x7ffee4f8c160>,
:                   'node-participation': <connsense.develop.topotap.TapDataset object at 0x7ffee4f8c310>,
:                   'simplex-counts': <connsense.develop.topotap.TapDataset object at 0x7fff2c9c4c40>,
:                   'thalamic-innervation': <connsense.develop.topotap.TapDataset object at 0x7ffee4f8c4c0>,
:                   'wm-innervation': <connsense.develop.topotap.TapDataset object at 0x7ffee4f8c550>}}
: <bluepy.circuit.Circuit at 0x7fff2c68fc10>
:END:

** Emacs specific :noexport:
We can get all figures displayed 95% so that we can work with them in front of us in an Emacs buffer. Here is a method that does that witb an example. This code is here only to see how much we use it. It should find a way to a place in our ~doom-config~.

#+NAME: fit-display-defun
#+BEGIN_SRC emacs-lisp :results silent
(defun fit-display-of (figure width height)
    (concat "#+attr_org: :width " width " :height " height (string ?\n) figure))
#+END_SRC

#+NAME: plot-display
#+HEADER: :var figure="this-should-be-path.png" :var width="95%" :var height="95%"
#+BEGIN_SRC emacs-lisp :results silent
(fit-display-of figure width height)
#+END_SRC

That we can use with ~:post~,
#+name: test-plot-display
#+HEADER: :results value file :file ./test-fit-fig.png
#+HEADER: :exports both :session return
#+HEADER: :post plot-display(figure=*this*)
#+BEGIN_SRC jupyter-python :post plot-display(figure=*this*)
import pandas as pd
from matplotlib import pyplot as plt
import seaborn as sbn

csv_url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data'
col_names = ['Sepal_Length','Sepal_Width','Petal_Length','Petal_Width','Class']
irisies = pd.read_csv(csv_url, names=col_names)

fig = plt.figure(figsize=(15, 12))
ax = sbn.histplot(x="Petal_Length", hue="Class", data=irisies, ax=fig.add_subplot())
#+END_SRC

#+RESULTS: test-plot-display
#+attr_org: :width 95% :height 95%
[[file:./test-fit-fig.png]]

We can also ~wrap~ with a function,
#+BEGIN_SRC emacs-lisp :results silent
(defun display-fig (&optional label caption attributes)
  "A wrap function for src blocks."
  (concat
   "ORG\n"
   "#+attr_org: :width 95%\n"
   (when caption
     (format "#+CAPTION: %s\n" caption))
   (when label
     (format "#+NAME: %s" label))
   (when caption
     (format "#+caption: %s" caption))))
#+END_SRC

and use it with ~:wrap~,
#+HEADER: :wrap (display-fig "fig-sin" "A sin wave.")
#+name: figure-sin-wave
#+BEGIN_SRC jupyter-python :session return
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path

x = np.linspace(0, 4 * np.pi, 1000)
y = np.sin(x)

fig = plt.figure(figsize=(15, 12))
axes = plt.plot(x, y)
p = Path.home() / 'work/workspaces/scratch/sin.png'
#plt.savefig(p)
#+END_SRC

#+RESULTS: figure-sin-wave
#+begin_ORG
#+attr_org: :width 95%
#+CAPTION: A sin wave.
#+NAME: fig-sin#+caption: A sin wave.
[[file:./.ob-jupyter/37a491009ff10b8f7c166bd48b8b9c748f68a9bf.png]]
#+end_ORG

#+NAME: fit-display
#+HEADER: :var figure="" :var attr_value="95%" :var attr_name="#+attr_html: :width "
#+BEGIN_SRC emacs-lisp
(concat attr_name attr_value (string ?\n) figure)
#+END_SRC

#+RESULTS: fit-display
: #+attr_html: :width 95%

#+NAME: attr-wrap
#+BEGIN_SRC sh :var figure="" :var width="95%" :results output
echo "#+attr_html: :width $width"
echo "$figure"
#+END_SRC

#+RESULTS: attr-wrap
: #+attr_html: :width 95%
:

* Introduction
We will study flatmap columns. In the circuit's flatmap we have the following grid,

#+BEGIN_SRC jupyter-python :file ./figures/flatmap.png :exports both
from flatmap_utility import subtargets as fmst
fmst.fmap_positions(circuit, over_flatmap_voxels=None, with_orientations=None,
                    to_subpixel_resolution=True, dropna=True)
#+END_SRC

#+RESULTS:
:RESULTS:
: /gpfs/bbp.cscs.ch/project/proj83/analyses/topological-analysis-subvolumes/proj83/topological-analysis-of-subvolumes/flatmap_utility/flatmap_utility.py:199: UserWarning: Optimal rotation is not uniquely or poorly defined for the given sets of vectors.
:   res = Rotation.align_vectors(vtgt, vv)
: Rotation errors: min: 0.0, median: 0.09387602600937707, mean: 0.1362824184485066, std: 0.15664142313770807, max: 2.0
#+begin_example
                   x            y
gid
1        2070.254580  2941.901129
2        2716.594415  2687.716832
3        1383.068384  1163.944134
4        1265.374093  1331.794667
5        2228.382838  4131.306090
...              ...          ...
4234925  2402.376474   534.494432
4234926  5337.546887  3190.549809
4234927   773.076963  6266.401067
4234928  1469.443366  4804.540715
4234929   207.636525  1589.479125

[3979592 rows x 2 columns]
#+end_example
:END:

#+HEADER: :post plot-display(figure=*this*)
#+BEGIN_SRC jupyter-python :file ./figures/flatmap.png :exports both
from flatmap_utility import subtargets as fmst, tessellate
flat_xys = fmst.fmap_positions(in_data=circuit)
tritille = tessellate.TriTille(230.0)
graphic_fmap_cells = tritille.plot_hextiles(flat_xys,
                                            annotate=False, with_grid=False, pointmarker=".", pointmarkersize=0.05)
graphic_fmap_cells[0]
#+END_SRC

#+RESULTS:
#+attr_org: :width 95% :height 95%
[[file:./figures/flatmap.png]]

* Pipeline: TODO
* TAP CLI
* Subtargets
We have information about subtargets in ~tap~,
#+HEADER: :comments both :exports code
#+BEGIN_SRC jupyter-python :tangle no
display(tap.subtargets)
#+END_SRC

Each one is a straight up cylinderical column in the flatmap-space, and a conical column in circuit's physical space. Each ~subtarget~ is associated with a list of gids,
#+HEADER: :comments both :exports both :var width="95%" :results output :post plot-display(figure=*this*)
#+BEGIN_SRC jupyter-python :tangle no :file ./figures/subtarget-sizes.png
fig_subtarget_sizes = plt.figure(figsize=(GOLDEN * 12, 12))

ax = sbn.histplot(tap.subtarget_gids.apply(len).values, bins=25,
                  ax=fig_subtarget_sizes.add_subplot())
#+END_SRC

#+RESULTS:
#+attr_html: :width 95% :height 95%
[[file:./figures/subtarget-sizes.png]]

We have ~subtargets~' ~conicality, volume, and height~ in the ~info~. We may not be able to compute these values for each ~flatmap-column~. Some may have a geometry that does not resolve to our computations. The ~nan~ values for ~conicality~ are found in,
#+BEGIN_SRC jupyter-python :file ./figures/nan_flatmap.png :exports both
flat_xy = OrderedDict([("flat_x", "x"), ("flat_y", "y")])
nanxys = tap.subtargets[list(flat_xy.keys())].rename(columns=flat_xy)

graphic_nanfmap = tritille.plot_hextiles(nangxys, annotate=False)
graphic_nanfmap[0]
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]
: [0;31m---------------------------------------------------------------------------[0m
: [0;31mNameError[0m                                 Traceback (most recent call last)
: [0;32m/tmp/ipykernel_28068/3521415563.py[0m in [0;36m<module>[0;34m[0m
: [1;32m      2[0m [0mnanxys[0m [0;34m=[0m [0mtap[0m[0;34m.[0m[0msubtargets[0m[0;34m[[0m[0mlist[0m[0;34m([0m[0mflat_xy[0m[0;34m.[0m[0mkeys[0m[0;34m([0m[0;34m)[0m[0;34m)[0m[0;34m][0m[0;34m.[0m[0mrename[0m[0;34m([0m[0mcolumns[0m[0;34m=[0m[0mflat_xy[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
: [1;32m      3[0m [0;34m[0m[0m
: [0;32m----> 4[0;31m [0mgraphic_nanfmap[0m [0;34m=[0m [0mtritille[0m[0;34m.[0m[0mplot_hextiles[0m[0;34m([0m[0mnangxys[0m[0;34m,[0m [0mannotate[0m[0;34m=[0m[0;32mFalse[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
: [0m[1;32m      5[0m [0mgraphic_nanfmap[0m[0;34m[[0m[0;36m0[0m[0;34m][0m[0;34m[0m[0;34m[0m[0m
:
: [0;31mNameError[0m: name 'tritille' is not defined
:END:
#+attr_html: :width 95% :height 95%
[[file:./figures/nan_flatmap.png]]

* Nodes
We extract node properties as ~extract-node-populations/default~, and can access the node-properties using ~tap~,

#+HEADER: :comments both :exports both
#+BEGIN_SRC jupyter-python :tangle no
nodes = cnstap.TapDataset(tap, ("extract-node-populations", "default"), belazy=False)
#+END_SRC

As you can tell from the numbers that the ~nodes~ dataframe contains all the nodes in all the subtargets (/i.e/ all circuit nodes except those that could not be flatmapped). This dataframe is no different from the ~circuit.cells~ one, except that the ~subtarget~ is avaialble in the index,
#+BEGIN_SRC jupyter-python :tangle no
display(nodes.frame[ ["gid", "layer", "mtype"] ].head())
#+END_SRC

Notice the ~node_id~ which is not the same as ~gid~. The ~node_id~ value is local to the ~subtarget~.

* Adjacency matrices
Adjacency matrices for edges in the local connectome were extracted as ~extract-edge-populations/local~. This data is stored as sparse matrices, and hence using ~.frame~ on the non-lazy data not make much sense. The data is also much larger than nodes. We should stick to the lazy ~datacalls~ loaded  by ~tap~,
#+BEGIN_SRC jupyter-python :tangle no
display(tap.adjacency.frame.head())
#+END_SRC

#+RESULTS:
: subtarget  circuit  connectome
: R18;C0     Bio_M    local         <connsense.develop.parallelization.DataCall ob...
: R19;C0     Bio_M    local         <connsense.develop.parallelization.DataCall ob...
: R18;C1     Bio_M    local         <connsense.develop.parallelization.DataCall ob...
: R19;C1     Bio_M    local         <connsense.develop.parallelization.DataCall ob...
: R16;C0     Bio_M    local         <connsense.develop.parallelization.DataCall ob...
: dtype: object
Each entry can be expanded when needed,
#+BEGIN_SRC jupyter-python :tangle no
adj = tap.adjacency.dataset.iloc[0]()

print("matrix of type", type(adj), "and shape", adj.shape,
      "number of connections", adj.astype(bool).sum())
#+END_SRC

#+RESULTS:
: matrix of type <class 'scipy.sparse.csr.csr_matrix'> and shape (4570, 4570) number of connections 431358

* Analyses
** Simplex counts
We already have results for simplex-counts in a ~tap-store~ resulting from a run of the ~connsense-pipeline- developed in [[Pipeline]]. Let us load the simplex-counts,
#+BEGIN_SRC jupyter-python
simplex_counts = cnstap.TapDataset(tap, ("analyze-connectivity", "simplex-counts"),
                                   belazy=False)
print("Simplex counts as a %s"%(type(simplex_counts),))
#+END_SRC

#+RESULTS:
: Simplex counts as a <class 'connsense.develop.topotap.TapDataset'>

We have run simplex counts for both the full (original and 5 ER controls) adjacency matrices, and their slices by layer. We can load the results for the ~full-flatcolumns~ as a dataframe,
#+BEGIN_SRC jupyter-python
simplex_counts.frame["full"]
#+END_SRC

#+RESULTS:
#+begin_example
dim                                              0         1         2  \
subtarget circuit connectome control
R18;C0    Bio_M   local      erdos-renyi-0  4570.0  431358.0  840153.0
                             erdos-renyi-1  4570.0  431358.0  840884.0
                             erdos-renyi-2  4570.0  431358.0  840077.0
                             erdos-renyi-3  4570.0  431358.0  840216.0
                             erdos-renyi-4  4570.0  431358.0  843070.0
...                                            ...       ...       ...
R3;C11    Bio_M   local      erdos-renyi-1     1.0       NaN       NaN
                             erdos-renyi-2     1.0       NaN       NaN
                             erdos-renyi-3     1.0       NaN       NaN
                             erdos-renyi-4     1.0       NaN       NaN
                             original          1.0       NaN       NaN

dim                                               3     4   5   6   7
subtarget circuit connectome control
R18;C0    Bio_M   local      erdos-renyi-0  33636.0  27.0 NaN NaN NaN
                             erdos-renyi-1  34024.0  32.0 NaN NaN NaN
                             erdos-renyi-2  34160.0  22.0 NaN NaN NaN
                             erdos-renyi-3  33681.0  36.0 NaN NaN NaN
                             erdos-renyi-4  34321.0  20.0 NaN NaN NaN
...                                             ...   ...  ..  ..  ..
R3;C11    Bio_M   local      erdos-renyi-1      NaN   NaN NaN NaN NaN
                             erdos-renyi-2      NaN   NaN NaN NaN NaN
                             erdos-renyi-3      NaN   NaN NaN NaN NaN
                             erdos-renyi-4      NaN   NaN NaN NaN NaN
                             original           NaN   NaN NaN NaN NaN

[1434 rows x 8 columns]
#+end_example

This computation will take a while, as all the simplex counts, for both the full and layer will be decompressed from ~connsense.h5~ and loaded into a ~pandas.DataFrame~. In about a minute you should see the result. Once loaded, the dataframe will stay with the object ~simplex_counts.frame~. For layers we have an extra level in the index,
#+BEGIN_SRC jupyter-python
simplex_counts.frame["layer"]
#+END_SRC

#+RESULTS:
#+begin_example
dim                                                    0        1        2  \
subtarget circuit connectome control       layer
R18;C0    Bio_M   local      erdos-renyi-0 1        49.0     50.0      NaN
                                           2       484.0   4802.0    984.0
                                           3       705.0  10299.0   3168.0
                                           4       866.0  15454.0   5649.0
                                           5      1116.0  25783.0  12544.0
...                                                  ...      ...      ...
R3;C11    Bio_M   local      original      2         1.0      NaN      NaN
                                           3         1.0      NaN      NaN
                                           4         1.0      NaN      NaN
                                           5         1.0      NaN      NaN
                                           6         1.0      NaN      NaN

dim                                                   3   4   5   6   7
subtarget circuit connectome control       layer
R18;C0    Bio_M   local      erdos-renyi-0 1        NaN NaN NaN NaN NaN
                                           2        4.0 NaN NaN NaN NaN
                                           3       19.0 NaN NaN NaN NaN
                                           4       37.0 NaN NaN NaN NaN
                                           5      119.0 NaN NaN NaN NaN
...                                                 ...  ..  ..  ..  ..
R3;C11    Bio_M   local      original      2        NaN NaN NaN NaN NaN
                                           3        NaN NaN NaN NaN NaN
                                           4        NaN NaN NaN NaN NaN
                                           5        NaN NaN NaN NaN NaN
                                           6        NaN NaN NaN NaN NaN

[8604 rows x 8 columns]
#+end_example

We find a ~nan~ where no simplices were found. Each individual computation on a single ~flatcolumn~ returns an array / series of simplex counts by dimension /upto/ the maximum dimension of simplices found in that ~flatcolumn~. When we concatenated these data into a single ~frame~, the max-dimension was set to the maximum of maxima over all ~flatcolumns~ (and their randomizations). This filled in ~nan~ values for ~flatcolumns~ that did not have the higher missing dimensions. While we can replace the ~nans~ by zeros, as that is what they mean, they do offer a convenient way to compute the max-dimension,

#+BEGIN_SRC jupy-python
from tqdm import tqdm; tqdm.pandas()

maxdim = (simplex_counts.frame["full"]
          .apply(lambda subtarget: len(subtarget.dropna()), axis=1)
          .rename("dim"))

display(maxdim)
#+END_SRC

#+RESULTS:
#+begin_example
subtarget  circuit  connectome  control
R18;C0     Bio_M    local       erdos-renyi-0    5
                                erdos-renyi-1    5
                                erdos-renyi-2    5
                                erdos-renyi-3    5
                                erdos-renyi-4    5
                                                ..
R3;C11     Bio_M    local       erdos-renyi-1    1
                                erdos-renyi-2    1
                                erdos-renyi-3    1
                                erdos-renyi-4    1
                                original         1
Name: dim, Length: 1434, dtype: int64
#+end_example

which we can convert to a plot,
#+HEADER: :comments both :exports both :post plot-display(figure=*this*)
#+BEGIN_SRC jupyter-python :file ./figures/violins_maxdim_vs_control.png
fig_maxdim = plt.figure(figsize=(GOLDEN * 8, 8))
_ax = sbn.violinplot(x="control", y="dim", data=maxdim.reset_index(),
                     ax=fig_maxdim.add_subplot())
fig_maxdim
#+END_SRC

#+RESULTS:
#+attr_html: :width 95% :height 95%
[[file:./figures/violins_maxdim_vs_control.png]]

What about each layer?
#+BEGIN_SRC jupyter-python
maxdim_by_layer = (simplex_counts.frame["layer"]
                   .apply(lambda subtarget: len(subtarget.dropna()), axis=1)
                   .rename("dim"))

display(maxdim_by_layer)
#+END_SRC

#+RESULTS:
#+begin_example
subtarget  circuit  connectome  control        layer
R18;C0     Bio_M    local       erdos-renyi-0  1        2
                                               2        4
                                               3        4
                                               4        4
                                               5        4
                                                       ..
R3;C11     Bio_M    local       original       2        1
                                               3        1
                                               4        1
                                               5        1
                                               6        1
NAME: dim, Length: 8604, dtype: int64
#+end_example

and it looks like,
#+HEADER: :comments both :file ./figures/violins_sliced_maxdim_vs_control.png :exports both
#+BEGIN_SRC jupyter-python :tangle no
fig_maxdim_by_layer = plt.figure(figsize=(GOLDEN * 8, 8))
_ax = sbn.violinplot(x="control", y="dim", hue="layer", data=maxdim_by_layer.reset_index(),
                     ax=fig_maxdim_by_layer.add_subplot())
fig_maxdim_by_layer
#+END_SRC

#+RESULTS:
#+attr_html: :width 95%
[[file:./figures/violins_sliced_maxdim_vs_control.png]]

** Model Params DD2
Loading the results for second order distance dependent model is similar to simplex counts,
#+BEGIN_SRC jupyter-python
params_dd2 = cnstap.TapDataset(tap, ("analyze-connectivity", "model-params-dd2"),
                               belazy=False)
display(params_dd2.frame)
#+END_SRC

#+RESULTS:
:RESULTS:
:  2023-02-28 09:38:19,607: Pour analyses for analyze-connectivity quantity model-params-dd2
:  2023-02-28 09:38:19,609: Initialize a DataFrameStore matrix store loading / writing data at /gpfs/bbp.cscs.ch/project/proj83/home/sood/topological-analysis-subvolumes/test/v2/connsense.h5 / analyses/connectivity/model-params-dd2
:  2023-02-28 09:38:23,108: Frame TapDataset (analyze-connectivity/model-params-dd2) component None
#+begin_example
                                   exp_model_scale  exp_model_exponent
subtarget circuit connectome seed
R18;C0    Bio_M   local      NaN          0.749694            0.006224
R19;C0    Bio_M   local      NaN          0.729469            0.005418
R18;C1    Bio_M   local      NaN          0.795972            0.008555
R19;C1    Bio_M   local      NaN          0.711651            0.006696
R16;C0    Bio_M   local      NaN          0.751695            0.006487
...                                            ...                 ...
R15;C14   Bio_M   local      NaN          0.941746            0.008906
R4;C12    Bio_M   local      NaN          0.911301            0.008335
R9;C15    Bio_M   local      NaN          0.658517            0.004572
R15;C13   Bio_M   local      NaN          0.266214            0.003580
R3;C11    Bio_M   local      NaN               NaN                 NaN

[239 rows x 2 columns]
#+end_example
:END:

** Simplices
We would like to analyze higher order statistics of simplices than the humble simplex counts. We could save simplices as lists for each subtarget input. However this data can be large. To reduce the computed data's size, we can compute statistics on each ~subtarget~'s simplices,
#+BEGIN_SRC jupyter-python
def node_participation(simplices):
    """Compute node participation from DataFrame of simplices,
    containing a list of simplices in each row.
    """
    return simplices.apply(lambda column: column.value_counts(), axis=0).fillna(0).astype(int)
#+END_SRC
or for edge participation,
#+BEGIN_SRC jupyter-python
def edge_participation(simplices):
    """Compute node participation from DataFrame of simplices,
    containing a list of simplices in each row.
    """
    edge_positions = list(range(simplices.shape[1]))[:-1]

    def value_count_edge(position):
        counts = simplices[ [position, position+1] ].value_counts().rename(position)
        counts.index.rename(["source", "target"], inplace=True)
        return counts

    return pd.concat([value_count_edge(p) for p in edge_positions], axis=1).fillna(0).astype(int)
#+END_SRC

* Connectome-utilities
Here we use ~conntility~. To load a circuit,
#+name: load-circuit
#+begin_src jupyter-python
import pandas
import numpy
import bluepy

circ_fn = "/gpfs/bbp.cscs.ch/project/proj83/circuits/Bio_M/20200805/CircuitConfig_TC_WM"
circ = bluepy.Circuit(circ_fn)
#+end_src

#+RESULTS: load-circuit

With a circuit in hand we can load a config with ~conntility~,
#+name: loader-config
#+begin_src jupyter-python
from conntility.circuit_models import neuron_groups

loader_config = {"loading": {"base_target": "Mosaic",
                             "properties": ["ss_flat_x", "ss_flat_y", "x", "y", "z", "layer",
                                            "synapse_class", "mtype", "etype"]},
                 "filtering": [{"column": "layer", "value": 4}],
                 "grouping": [{"method": "group_by_grid",
                               "columns": ["ss_flat_x", "ss_flat_y"],
                               "args": [230.0],
                               "kwargs": {"prefix": "hex230-"}}]}

base_group = neuron_groups.load_group_filter(circ, loader_config)
base_group = base_group.loc[base_group["hex230-x"] > -1E6]

display(base_group)
#+end_src

#+RESULTS: loader-config
:RESULTS:
: /gpfs/bbp.cscs.ch/project/proj83/home/sood/proj83-rsync/Connectome-utilities/conntility/flatmapping/_supersample_utility.py:136: UserWarning: Optimal rotation is not uniquely or poorly defined for the given sets of vectors.
:   res = Rotation.align_vectors(vtgt, vv)
: Rotation errors: min: 0.0, median: 0.09387602600937707, mean: 0.1362824184485066, std: 0.15664142313770807, max: 2.0
#+begin_example
                    etype  layer   mtype synapse_class            x  \
hex230-i hex230-j
-7       11          cNAC      4   L4_BP           INH  3935.875808
 7       13        cACint      4   L4_BP           INH  5429.642871
-25      26          bNAC      4   L4_BP           INH  1964.702652
-23      31          cNAC      4   L4_BP           INH  2625.043789
 9       12          cNAC      4   L4_BP           INH  5243.143890
...                   ...    ...     ...           ...          ...
 4       16         cSTUT      4  L4_LBC           INH  5454.385788
 6       9           dNAC      4  L4_LBC           INH  4803.351240
-9       15          dNAC      4  L4_LBC           INH  3967.728001
 2       26          cNAC      4  L4_LBC           INH  5921.843550
-4       5           dNAC      4  L4_LBC           INH  3839.505128

                             y            z      gid    ss_flat_x  \
hex230-i hex230-j
-7       11       -2120.645544 -2156.657847  2206292   723.002011
 7       13       -1262.427607 -4874.859457  2206293  4087.381313
-25      26        1091.962301 -1301.027629  2206294   183.262735
-23      31        2167.404245 -1035.677347  2206295  1467.736632
 9       12       -1681.832926 -5378.442266  2206296  4109.221373
...                        ...          ...      ...          ...
 4       16        -859.306284 -4217.743437  2885708  3813.424272
 6       9        -2302.172723 -4608.297791  2885709  2882.768952
-9       15       -1128.846627 -2056.902446  2885710  1319.944360
 2       26        1415.952912 -4478.548625  2885711  5476.205274
-4       5        -3086.204151 -2490.231175  2885712   256.305188

                     ss_flat_y     hex230-x  hex230-y hex230-subtarget
hex230-i hex230-j
-7       11        1920.459284   796.743371    2070.0            R6;C2
 7       13         705.720657  3983.716857     690.0           R2;C10
-25      26        5823.590582   199.185843    5865.0           R17;C0
-23      31        6209.748800  1593.486743    6210.0           R18;C4
 9       12         191.553310  4182.902700     345.0           R1;C10
...                        ...          ...       ...              ...
 4       16        1406.395811  3983.716857    1380.0           R4;C10
 6       9          405.078887  2987.787643     345.0            R1;C7
-9       15        2724.312314  1195.115057    2760.0            R8;C3
 2       26        2917.727638  5577.203600    2760.0           R8;C14
-4       5          946.839179   199.185843    1035.0            R3;C0

[639422 rows x 13 columns]
#+end_example
:END:

We can load a matrix of connections /between/ the defined groups. We load the midrange connection count.
#+name: midrange-connection-count
#+begin_src jupyter-python
from conntility import circuit_models
M = circuit_models.circuit_matrix_between_groups(circ, base_group,
                                                 connectome="intra_SSCX_midrange_wm",
                                                 extract_full=True)
#+end_src

* Scratch
#+HEADER: :comments both  :exports both :file ./figures/file-name-for-figure.png
#+BEGIN_SRC jupyter-python :tangle no
#+END_SRC
* Meetings
** <2023-06-27 Tue>
The manuscripts, physiology has taken shape, and structural is being redone.
