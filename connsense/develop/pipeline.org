#+title: A pipeline to analyze networks with multiple populations and /multi-edge/ connections.

The brain circuit's connections are mediated via multiple-synapses, and may consitute of multiple node populations.
Here we develop features in ~connsense~ to handle such features of a brain network.
Instead of defining individual sections, we will develop the complete description.

#+name: config-init
#+begin_src yaml :tangle no :noweb yes :padline no
description: >-
  Configure a `connsense` pipeline
version: 2.0.0
date: 20220720
#+end_src

There will be two sections in the /pipeline/ config.

* Paths
The section ~paths~ configures the locations of the circuit to analyze, and HDF5 paths for the ~TAP-store~~.

#+name: config-paths
#+begin_src yaml :tangle no :noweb yes :padline no
paths:
  description: >-
    The ~connsense~ pipeline needs paths to the input data to load from, and output paths to store data.
    Paths to the circuit must be provided along with paths to the HDF5 archive that will store the pipeline's
    results.
  format: relative
  circuit:
    root: "/gpfs/bbp.cscs.ch/project/proj83/circuits"
    files:
      Bio_M: "Bio_M/20200805/CircuitConfig_TC_WM"
  pipeline:
    root: "/gpfs/bbp.cscs.ch/project/proj83/home/sood/portal/develop/factology-v2/analyses/connsense/"
    steps:
      define-subtargets: "subtargets"
      extract-nodes: "nodes"
      evaluate-subtargets: "subtarget_quality"
      extract-connectivity: "edges/original"
      randomize-connectivity: "edges/randomized"
      analyze-connevtivity: "analysis"
    input:
      store: "connsense.h5"
    output:
      store: "connsense.h5"
#+end_src

* Parameters
We can configure ~connsense~ to use methods provided in the ~parameters~ section.
The parameters section will be a mapping of pipeline step to it's parameters.

#+name: config-parameters
#+begin_src yaml :tangle no :noweb yes :padline no

parameters:
  description: >-
    Configure parameters for each pipeline step as a mapping.
#+end_src

** Define subtargets
We can analyze several groups of subtargets, each defined by an entry in the configuration.
A definition of subtargets will have it's own parameters that makes sense to the code that implements the definition.
However, each defintiion must apply to a specified node population. The same value for attribute ~node-population~
must be used to extract it's node-properties. Ideally this value should be the same as entered in the circuit's
SONATA files.

#+name: config-parameters-define-subtargets
#+begin_src yaml :tangle no :noweb yes :comments org :padline no
define-subtargets:
  description: >-
    Configure how subtargets are defined.

  definitions:
    hexgrid-cells:
      description: >-
         A hexagonal grid in the circuit's flatmap space (a.k.a flatspace),
         using methods provided in connsense/flatmap_utility.
         Cell positions will be distributed among the hexagonal subtargets, in a grid generated with
         the configured parameters.
      node_population: "default"
      shape: hexgrid
      parameters:
      origin: [0.0, 0.0, 0.0]
      radius: 230.0
      base_target: "Mosaic"
    hexgrid-voxels:
      description: >-
        A hexagonal grid in the circuit's flatmap space (a.k.a flatspace),
        using an NRRD file that maps each voxel to the subtarget it belongs in.
        In addition to the NRRD file, a file providing subtarget info is also required.
      node_population: "default"
      nrrd: "/gpfs/bbp.cscs.ch/project/proj83/home/reimann/subvolumes/column_identities.nrrd"
      info: "/gpfs/bbp.cscs.ch/project/proj83/home/reimann/subvolumes/voxel-based-hex-grid-info.h5"
    pre-defined:
      description: >-
        The pre-defined subtargets' node-ids  must be available in the circuit's data.
        The entries should be of the form `<group>/<member>` such that the entry can be used the subtarget's
        NRRD mask from `circuit.atlas`. Subtargets will be defined using a `connsense` method that uses `bluepy`
        to extract each subtarget's GIDs from the circuit.
      node_population: "default"
      subtargets:
        - "central_columns/S1DZO_Column"
        - "central_columns/S1DZ_Column"
        - "central_columns/S1FL_Column"
        - "central_columns/S1HL_Column"
        - "central_columns/S1J_Column"
        - "central_columns/S1Sh_Column"
        - "central_columns/S1Tr_Column"
        - "central_columns/S1ULp_Column"
#+end_src


** Extract nodes
To configure the extraction of nodes, we must specify node populations in the circuit.

All nodes will be saved in the HDF5 group /nodes/,
and parameterized by listing individual populations as mappings of population name to a mapping to configure
the node extraction. Each population's configuration must include a reference to the source code to extract it's nodes.
For the SSCx dissemination circuit we specify the population to be named /default/, and use the extractor provided
packaged in ~connsense~ that uses ~bluepy~. The properties to extract must also be provided.

#+name: config-parameters-extract-nodes
#+begin_src yaml :tangle no :noweb yes :comments no :padline no
extract-nodes:
  description: >-
    Specify the populations to extract from a circuit.
  populations:
    default:
      description: >-
        The default population will be that of neurons in the SSCx.
        To extract the neurons we will use a `connsense` method that uses ~bluepy~.
      extractor:
        source: connsense
        method: bluepy
      properties:
        - region
        - layer
        - x
        - y
        - z
        - depth
        - synapse_class
        - mtype
        - etype
        - morphology
#+end_src

Let us now implement a ~Python~ method to handle the configuration above.
We can multiple circuit's for the ~connsense.pipeline~ to compute. The methods below will work on a single
circuit.

#+name: method-extract-nodes
#+begin_src python :tangle no :noweb yes :comments org :padline no

def check_populations(in_config):
    """Check parameters to extract nodes in a config.\
    """
    extract_neurons = in_config["extract-nodes"]
    return extract_neurons["populations"]


def check_paths(in_config):
    """Check paths to extract nodes in a config.
    """
    return read_config.check_paths(in_config)


def extract_population(params, subtargets, from_circuit):
    """..."""
    _, extract = plugins.import_module(params["extractor"]["source"], params["extractor"]["method"])
    return extract(from_circuit, subtargets, params["properties"])


def extract_nodes(in_circuit, as_configured):
    """Extract nodes configured in a YAML / JSON file.
    """
    in_config = read(as_configured)
    populations = check_populations(in_config)

    input_paths, output_paths = check_paths(in_config)
    path_targets = output_paths["steps"]["define-subtargets"]
    subtargets = read_results(path_targets, for_step="define-subtargets")

    return {p: extract_population(params, subtargets[p], in_circuit) for p, params in populations.items()}
#+end_src


** Evaluate subtargets
How good are the subtargets we have defined in the previous sections?
Consider the flatmap subtargets we have developed for the SSCx. We expect these subtargets to be conical in shape,
the radius increasing along its principal axis oriented from the white-matter to pia.
We would add a computation among the metrics that evaluate the subtargets.
At the moment of <2022-07-20 Wed> we do not have any metrics entered below. So this configuration step will not work.
However writing it out, we learn how this step should work.

#+name: config-parameters-evaluate-subtargets
#+begin_src yaml :tagnle no :noweb yes :comments org :padline no
evaluate-subtargets:
  description: >-
    To evaluate the subtargets defined in the previous step, we define the metrics to be provided by connsense.
  metrics:
    orthogonality:
      description: >-
        Subtargets must be non-overlapping. How orthogonal / non-overlapping are the subtargets?
      apply-to-subtargets:
        - hexgrid-cells
        - hexgrid-voxels
        - pre-defined
      source: connsense.evaulate_subtargets.metrics
      method: orthogonality

    conicality:
      description: >-
        How conical are the flatmap subtargets?
      apply-to-subtargets:
        - hexgrid-cells
        - hexgrid-voxels
      source: connsense.evaluate_subtargets.metrics
      method: conicality

    neuron_counts:
      description: >-
        Number of neurons in a subtarget. The number can be used to indicate outliers. Too small may be removed.
      apply-to-subtargets:
        - hexgrid-cells
        - hexgrid-voxels
        - pre-defined
      source: connsense.evaulate_subtargets.metrics
      methods: neuron_counts

    target_composition:
      description: >-
        Composition of the subtargets by layer, and mtype using a method in `connsense`.
        A custom method may be provided.
      apply-to-subtargets:
        - hexgrid-cells
        - hexgrid-voxels
        - pre-defined
      source: connsense.evaulate_subtargets.metrics
      methods: target_composition
#+end_src


** Extract connectivity / edges
To extract the circuit's edges, we will list the circuit's /connectomes/. If we want to extract edge-properties
(/i.e./ synapse properties), we will list them.

#+name: synapse-properties-to-extract
#+begin_src yaml :tangle no :noweb yes :comments no :padline no
 - "type"
 - "g_synx"
 - "u_syn"
 - "d_syn"
 - "f_syn"
 - "axonal_delay"
 - "dtc"
 - "nrrp"
 - "touch_distance"
 - "conductance_ratio"
 - "u_hill_coefficient"
#+end_src

#+name: config-parameters-extract-connectivity
#+begin_src yaml :tangle no :noweb yes :comments no :padline no
extract-connectivity:
  description: >-
    Specify the connectomes to extract from.
    Connections will be extracted for each subtarget as an adjacency matrix, with or without connection-strengths.
    A connection is between a pair of source and target nodes, and may be a multi-edge connection.
    We will also specify a set of edge-properties to extract from the circuit.
  populations:
    local:
      source_node_population: "default"
      target_node_population: "default"
      connectome: "local"
      extractor:
        source: connsense.extract_connectivity.bluepy
        method: extract_connectivity
      properties:
        <<synapse-properties-to-extract>>

    long-range:
      source_node_population: "default"
      target_node_population: "default"
      connectome: "intra_SSCX_midrange_wm"
      extractor:
        source: connsense.extract_connectivity.bluepy
        method: extract_connectivity
      properties:
        <<synapse-properties-to-extract>>
    cortico-cortical:
      source_node_population: "default"
      target_node_population: "default"
      connectome: ["local", "intra_SSCX_midrange_wm"]
      extractor:
        source: connsense.extract_connectivity.bluepy
        method: extract_connectivity
      properties:
        <<synapse-properties-to-extract>>
    thalamic-vpm:
      source_node_population: null
      target_node_population: "default"
      connectome: "Thalamocortical_input_VPM"
      extractor:
        source: connsense.extract_connectivity.bluepy
        method: extract_connectivity
      properties:
        <<synapse-properties-to-extract>>
    thalamic-pom:
      source_node_population: null
      target_node_population: "default"
      connectome: "Thalamocortical_input_POM"
      extractor:
        source: connsense.extract_connectivity.bluepy
        method: extract_connectivity
      properties:
        <<synapse-properties-to-extract>>
#+end_src

** Analyze connectivity
Parameters for analyses will be a mapping from analyses to it's parameters.

#+name: config-parameters-analyze-connectivity
#+begin_src yaml :tangle no :noweb yes :comments no :padline no
analyze-connectivity:
  description:
    Configure each analyses' parameters, as a mapping under section `analyses`.
  analyses:
#+end_src

Let us configure an analyses of synaptic convergence. The analysis method will not have access to the circuit.
Instead it will be passed the adjacency matrix, and node and edge properties.

#+name: config-parameters-analyze-connectivity-synaptic-convergence
#+begin_src yaml :tangle no :noweb yes :comments no :padline no
synaptic-convergence:
  description:
    Compute synaptic convergence in a circuit for each mtype--> mtype pathway among edges in the local population.
  edge_population: "local"
  computation:
    args: ["adjacency_matrix", "node_properties", "edge_properties"]
    source: "sscx_dissemination.v2.circuit.factology.helper.connectome"
    method: "get_synaptic_convergence"
    output: "pandas.DataFrame"
#+end_src

Next, consider an analysis to compute the neuronal divergence. Such a method does not need edge-properties.

#+name: config-parameters-analyze-connectivity-intrinsic-extrinsic-connections
#+begin_src yaml :tangle no :noweb yes :comments no :padline no
neuronal-convergence:
  description:
    Compute neuronal convergence in a circuit for each mtype--> mtype pathway among edges in the local population.
  edge_population: "local"
  computation:
    args: ["adjacency_matrix", "node_properties"]
    source: "sscx_dissemination.v2.circuit.factology.helper.connectome.connectome"
    method: "get_neuronal_convergence"
    output: "pandas.DataFrame"
#+end_src

Thats' it. We can enter analyses one by one. However before we will have to refactor ~connsense~ to define subtargers,
extract neurons, and connectivity using the configs defined above.

* Results
The result of our discussion is the YAML configuration:

#+begin_src yaml :tangle pipeline.yaml :noweb yes :comments no :padline no
<<config-init>>

<<config-paths>>

<<config-parameters>>
  <<config-parameters-define-subtargets>>

  <<config-parameters-extract-nodes>>

  <<config-parameters-evaluate-subtargets>>

  <<config-parameters-extract-connectivity>>

  <<config-parameters-anlyze-connectivity>>
#+end_src
